遇到个很有意思的bug。

问题描述：在配置主从复制的时候，由于我选择将动态主从(主从数据源)切换的任务交给Spring的`AbstractRoutingDataSource`，所以我需要先创建`masterdruiddatasource`和`slavedruiddatasource`两个bean,并将它们放入`AbstractRoutingDataSource`的我的实现类`DynamicDataSource`中进行管理,最后让mybatis使用的是`DynamicDataSource`数据源。但是就因为`@Configuration`配置的特殊性导致出现了问题。配置`DynamicDataSource`这个Bean的参数上面需要有`masterdruiddatasource`和`slavedruiddatasource`两个Bean，来方便方法体内进行setter设置。然而Spring在使用configuration创建Bean时（`createBeanInstance()`方法中）会先对其参数进行解析,解析过程中就会调用`getBean()`来得到具体的对象。然而要命的是调用`getBean(masterdruiddatasource)`时Spring发现`DruidDataSouce`中有对一个`DataSourceInitializerInvoker`类的依赖,而这个类又有对`DynamicDataSource`的依赖,这就造成了一个循环依赖关系。而这种循环依赖不是普通的构造器循环依赖或者是属性依赖，而是`@Configuration`中方法的依赖,现在只是在创建`DynamicDataSource`Bean方法的参数注入流程中,根本就还没有`DynamicDataSource`这个Bean,所以这个问题Spring是绝对无法解决的（Spring不可能帮你创建这个Bean吧，因为这个方法就是你自定义的逻辑，Spring怎么能自己随意改动这个逻辑呢）。说到底还是bean生成顺序的问题，只需要先加载`masterdruiddatasource`，由他来驱动依赖加载从而让`DynamicDataSource`最后才加载,那么此时这个问题就变成了一个普通的循环依赖问题得以解决。所以只能用@DependsOn



这个考虑过后没有才说

问题描述：再增加了主从复制模块之后查询全部返回null

最终定位到自己写的ThreadLocal数据库切换的AroundAdvice没有设置返回值，重新看看源码才发现他调用的是`return invokeAdviceMethod()`,才知道原来有返回值,也就是说它的返回值对这个调用有影响。由于看过AOP源码after和before都是直接调用在finally块中调用`invokeAdviceMethod()`或者是直接调用,并没有返回值,所以并没有对`AroundAdvice`有特别的印象.

