遇到个很有意思的bug。

问题描述：在配置主从复制的时候，由于我选择将动态主从(主从数据源)切换的任务交给Spring的`AbstractRoutingDataSource`，所以我需要先创建`masterdruiddatasource`和`slavedruiddatasource`两个bean,并将它们放入`AbstractRoutingDataSource`的我的实现类`DynamicDataSource`中进行管理,最后让mybatis使用的是`DynamicDataSource`数据源。但是就因为`@Configuration`配置的特殊性导致出现了问题。配置`DynamicDataSource`这个Bean的参数上面需要有`masterdruiddatasource`和`slavedruiddatasource`两个Bean，来方便方法体内进行setter设置。然而Spring在使用configuration创建Bean时（`createBeanInstance()`方法中）会先对其参数进行解析,解析过程中就会调用`getBean()`来得到具体的对象。然而要命的是调用`getBean(masterdruiddatasource)`时Spring发现`DruidDataSouce`中有对一个`DataSourceInitializerInvoker`类的依赖,而这个类又有对`DynamicDataSource`的依赖,这就造成了一个循环依赖关系。而这种循环依赖不是普通的构造器循环依赖或者是属性依赖，而是`@Configuration`中方法的依赖,现在只是在创建`DynamicDataSource`Bean方法的参数注入流程中,根本就还没有`DynamicDataSource`这个Bean,所以这个问题Spring是绝对无法解决的（Spring不可能帮你创建这个Bean吧，因为这个方法就是你自定义的逻辑，Spring怎么能自己随意改动这个逻辑呢）。说到底还是bean生成顺序的问题，只需要先加载`masterdruiddatasource`，由他来驱动依赖加载从而让`DynamicDataSource`最后才加载,那么此时这个问题就变成了一个普通的循环依赖问题得以解决。所以只能用@DependsOn



这个考虑过后没有才说

问题描述：再增加了主从复制模块之后查询全部返回null

最终定位到自己写的ThreadLocal数据库切换的AroundAdvice没有设置返回值，重新看看源码才发现他调用的是`return invokeAdviceMethod()`,才知道原来有返回值,也就是说它的返回值对这个调用有影响。由于看过AOP源码after和before都是直接调用在finally块中调用`invokeAdviceMethod()`或者是直接调用,并没有返回值,所以并没有对`AroundAdvice`有特别的印象.



问题描述：分类搜索怎么实现的

在MySQL中建立了一个type表，blabla介绍表和索引，然后通过在subtitle使用倒排索引join上type表得出相应的vname和封面图

问题描述：双语搜索怎么实现的

后端根据选择的语言，使用不同的索引查询不同的列

问题描述：字慕相应图片展示

先在后端解析得到字幕出现的位置，再使用ffmpeg对视频文件进行裁剪得出截图，然后这些截图将作为静态资源放在服务器上被读取。由于数据库中每一条字幕相应的图片路径都有一个字段存储，所以能够直接读取出来

问题描述：热词怎么维护

首先对于热度的提升我考虑了几个方面。一个就是防刷热度，第二就是定期移除在排行榜末尾且已过期的键。

对于排行榜的热度提升和防刷热度，我将其放在了AOP中来做。首先再Controller中将HttpRequest放进TL中，之后在AOP中取出，解析出其IP地址，然后构建一个以ip地址为key的BF，在增加热度之前先判断该BF中是否存在这个热词，如果没有就向排行榜中增加热度，有就不增，最后设置一下BF的过期时间为10分钟，防止BF过多。

在AOP中除了上面功能外，还会维护一个热度过期的时间，设置一个ttl：热词的string默认过期时间1天，每次获取该热词都会刷新这个ttl，但若太长时间没有人搜索这个热词，那么他就会失效。此时每十分钟执行的定时删除任务将从排行榜中取出热度最低的10个键，判断它的ttl将其删除，以防止排行榜热词过多。



问题描述：怎么做主从的

首先就是主从数据库的搭建，在主库的配置文件中设置binlog开启并设置其名字，然后在主库创建复制客户端账号。随后在从库中调用change master to命令复制主库。

而对于读写分离逻辑则是通过AOP+Spring内置的动态数据源切换类`AbstractRoutingDataSource`实现的。其原理就是在配置DataSource的时候，选用我们自己的实现类即`AbstractRoutingDataSource`的实现类，而因为是动态数据源切换，所以要先创建主从两个数据源的Bean，在配置我们的实现类时将这主从数据源Bean设置到`AbstractRoutingDataSource`的HashMap中，而它的Key就是动态切换的关键，在这里我使用了enum作为它的Key。调用mybatis选用数据源的时候，首先会调用我们的`AbstractRoutingDataSource`实现类实现的`determineCurrentLookupKey()`方法来决定本次数据库ddl选择哪个数据源,根据我们返回的值也就是enum选择具体的数据源。所以这个方法要怎么实现动态的key切换呢，答案就是用AOP+TL。对一些写方法我们就用AOP对其增强，增强逻辑就是修改对应的TLMap的enum值，然后`determineCurrentLookupKey()`就负责从TL中取出具体的enum值来决定数据源的使用，这就很解耦了。







对于AOP，解决的问题就是Aware接口。

其次就说一下通过listener配置，启动你的容器，通过Reader类扫描包获得其中的类名加入进BeanDefinitionMap中，而AOP的Reader则之家加入一个BeanPostProcessor到Map中