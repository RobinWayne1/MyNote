# 八大排序

稳定性是指两个相同的数的相对位置在排序完成之后不会改变

## 一、算法分析

### 冒泡排序

冒泡排序就是把小的元素往前调或者把大的元素往后调。比较是相邻的两个元素比较，交换也发生在这两个元素之间。所以，如果两个元素相等，我想你是不会再无聊地把他们俩交换一下的；如果两个相等的元素没有相邻，那么**即使通过前面的两两交换把两个相邻起来，这时候也不会交换，所以相同元素的前后顺序并没有改变，所以冒泡排序是一种稳定排序算法。**

### 插入排序

插入排序是在一个已经有序的小序列的基础上，一次插入一个元素。当然，刚开始这个有序的小序列只有1个元素，就是第一个元素。比较是从有序序列的末尾开始，也就是想要插入的元素和已经有序的最大者开始比起，如果比它大则直接插入在其后面，否则一直往前找直到找到它该插入的位置。**如果碰见一个和插入元素相等的，那么插入元素把想插入的元素放在相等元素的后面。所以，相等元素的前后顺序没有改变，从原无序序列出去的顺序就是排好序后的顺序，所以插入排序是稳定的。**

### 快速排序

快速排序有两个方向，左边的i下标一直往右走，当a[i] <= a[center_index]，其中center_index是中枢元素的数组下标，一般取为数组第0个元素。而右边的j下标一直往左走，当a[j] > a[center_index]。如果i和j都走不动了，i <= j，交换a[i]和a[j],重复上面的过程，直到i > j。 交换a[j]和a[center_index]，完成一趟快速排序。**在中枢元素和a[j]交换的时候，很有可能把前面的元素的稳定性打乱.**

> 比如序列为5 3 3 4 3 8 9 10 11，现在中枢元素5和3（第5个元素，下标从1开始计）交换就会把元素3的稳定性打乱，所以快速排序是一个不稳定的排序算法，不稳定发生在中枢元素和a[j] 交换的时刻。

### 归并排序

归并排序是把序列递归地分成短序列，递归出口是短序列只有1个元素（认为直接有序）或者2个序列（1次比较和交换），然后把各个有序的段序列合并成一个有序的长序列，不断合并直到原序列全部排好序。可以发现，在1个或2个元素时，1个元素不会交换，2个元素如果大小相等也没有人故意交换，这不会破坏稳定性。那么，在短的有序序列合并的过程中，稳定是是否受到破坏？没有，**合并过程中我们可以保证如果两个当前元素相等时，我们把处在前面的序列的元素保存在结果序列的前面(相同的元素都是一起移动的)，这样就保证了稳定性。**所以，归并排序也是稳定的排序算法。

### 基数排序

基数排序是按照低位先排序，然后收集到桶中；当序列中所有的元素都分配到对应的桶中，再按照顺序依次将桶中的元素收集形成新的一个待排序列,然后再进行高位的桶收集操作；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序，最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。基数排序基于分别排序，分别收集，所以其是稳定的排序算法。

### 希尔排序

希尔排序是按照不同步长对元素进行插入排序，当刚开始元素很无序的时候，步长最大，所以插入排序的元素个数很少，速度很快；当元素基本有序了，步长很小， 插入排序对于有序的序列效率很高。所以，希尔排序的时间复杂度会比O(n^2)好一些。由于多次插入排序，我们知道一次插入排序是稳定的，不会改变相同元素的相对顺序，但在不同的插入排序过程中，相同的元素可能在各自的插入排序中移动，最后其稳定性就会被打乱，所以shell排序是不稳定的。

### 堆排序

我们知道堆的结构是节点i的孩子为2 * i和2 * i + 1节点，大顶堆要求父节点大于等于其2个子节点，小顶堆要求父节点小于等于其2个子节点。在一个长为n 的序列，堆排序的过程是从第n / 2开始和其子节点共3个值选择最大（大顶堆）或者最小（小顶堆），这3个元素之间的选择当然不会破坏稳定性。但当为n / 2 - 1， n / 2 - 2， ... 1这些个父节点选择元素时，就会破坏稳定性。有可能第n / 2个父节点交换把后面一个元素交换过去了，而第n / 2 - 1个父节点把后面一个相同的元素没 有交换，那么这2个相同的元素之间的稳定性就被破坏了。所以，堆排序不是稳定的排序算法。

## 二、时空分析

1、冒泡排序不管序列是怎样，都是要比较n(n-1)/2 次的，最好、最坏、平均时间复杂度都为O(n²)，需要一个临时变量用来交换数组内数据位置，所以空间复杂度为O(1)。有很多人说冒泡排序的最优的时间复杂度为O(n),其实这是在代码中使用一个标志位来判断是否已经排序好的,是冒泡排序的优化版，如果元素已经排序好，那么循环一次就直接退出。

------

2、选择排序是冒泡排序的改进，同样选择排序无论序列是怎样的都是要比较n(n-1)/2次的，最好、最坏、平均时间复杂度也都为O(n²)，需要一个临时变量用来交换数组内数据位置，所以空间复杂度为O(1)。

------

3、插入排序不同，如果序列是完全有序的，插入排序只要比较n次，无需移动时间复杂度为O(n)，如果序列是逆序的，插入排序要比较O(n²)和移动O(n²) ，所以平均复杂度为O(n²)，最好为O(n)，最坏为O(n²)，排序过程中只要一个辅助空间，所以空间复杂度O(1)。

------

4、快速排序的时间复杂度最好是O(nlog2n),平均也是O(nlog2n),最坏情况是序列本来就是有序的，此时时间复杂度为O(n²)，快速排序的空间复杂度可以理解为递归的深度，而递归的实现依靠栈，平均需要递归logn次，所以平均空间复杂度为O(log2n)。

------

5、归并排序需要一个临时temp[]来储存归并的结果，空间复杂度为O(n)，时间复杂度为O(nlog2n)，可以将空间复杂度由 O(n) 降低至 O(1)，然而相对的时间复杂度则由 O(nlogn) 升至 O(n²)。

------

6、希尔排序的时间复杂度分析及其复杂，有的增量序列的复杂度至今还没人能够证明出来，只需要记住结论就行，{1,2,4,8,...}这种序列并不是很好的增量序列，使用这个增量序列的时间复杂度（最坏情形）是O(n²)，Hibbard提出了另一个增量序列{1,3,7，...,2^k-1}，这种序列的时间复杂度(最坏情形)为O(n^1.5)，Sedgewick提出了几种增量序列，其最坏情形运行时间为O（n^1.3）,其中最好的一个序列是{1,5,19,41,109,...}，需要一个临时变量用来交换数组内数据位置，所以空间复杂度为O(1)。

------

7、堆排序的时间复杂度，主要在初始化堆过程和每次选取最大数后重新建堆的过程，初始化建堆时的时间复杂度为O(n)，更改堆元素后重建堆的时间复杂度为O(nlog2n)，所以堆排序的平均、最好、最坏时间复杂度都为O(nlog2n)，堆排序是就地排序，空间复杂度为常数O(1)。

------

8、基数排序对于 n 个记录，执行一次分配和收集的时间为O(n+r)，如果关键字有 d 位，则要执行 d 遍，所以总的时间复杂度为 O(d(n+r))。该算法的空间复杂度就是在分配元素时，使用的桶空间，空间复杂度为O(r+n)=O(n)

------

以上是我自己的总结，每个算法都附有链接，下图是我自己整理的表格，喜欢的话别忘了点个赞哦

![图片说明](https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWRmaWxlcy5ub3djb2Rlci5jb20vaW1hZ2VzLzIwMTkwNjIyLzUyMjc0NDBfMTU2MTE4MzUwNTQ0MF9DMkFFRUJCQTQ0MkQ2MzYxQjhENzgxQkFGQUY4QkY5Qg?x-oss-process=image/format,png)

------

### 排序算法适用场景

- 若n较小(如n≤50)，可采用直接插入或直接选择排序。当记录规模较小时，直接插入排序较好，否则因为直接选择移动的记录数少于直接插人，应选直接选择排序为宜。
- 若序列初始状态基本有序，则直接插入和冒泡最佳，随机的快速排序也不错。插入排序对部分有序的数组很有效，所需的比较次数平均只有选择排序的一半。
- 若n较大，则应采用时间复杂度为O(nlgn)的排序方法：快速排序、堆排序或归并排序。
  - 快速排序是目前基于比较的内部排序中被认为是最好的方法，当待排序的关键字是随机分布时，快速排序的平均时间最短；
  - 堆排序所需的辅助空间少于快速排序，并且不会出现快速排序可能出现的最坏情况。但这两种排序都是不稳定的。
  - 若要求排序稳定，则可选用归并排序。两两归并的排序算法并不值得提倡，通常可以将它和直接插入排序结合在一起使用。先利用直接插入排序求得较长的有序子文件，然后再两两归并之。因为直接插入排序是稳定的，所以改进后的归并排序仍是稳定的。
- 希尔排序比插入排序和选择排序要快得多，并且数组越大，优势越大。如果需要解决一个排序问题而又没有系统排序函数可用（例如直接接触硬件或者运行于嵌入式系统中的代码），可以先用希尔排序，再考虑是否替换为更复杂的排序算法。而对于部分有序和小规模的数组，应使用插入排序。
- 归并排序可以处理数百万甚至更大规模的数组，但是插入排序和选择排序做不到。归并排序的主要缺点是辅助数组所使用的额外空间和n的大小成正比。
- 快速排序的优点是原地排序（只需要一个很小的辅助栈），但是基准的选取是个问题，对于小数组，快速排序要比插入排序慢。
- 堆排序的优点是在排序时可以将需要排序的数组本身作为堆，无需任何额外空间，与选择排序有些类似，但所需的比较要少得多，堆排序适合例如嵌入式系统或低成本移动设备中容量有限的场景。