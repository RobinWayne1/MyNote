# 跳跃表

首先来讲一下二分查找。二分查找就是对一个有序数组，每次都寻找其部分的中点下标并比较其值，用于判断下一次二分查找的位置。这种查找是最快的查找方式。然而为什么需要二叉搜索树呢？就是因为这些数据结构的底层使用的是不支持随机访问的链表格式，所以才需要这些树和跳跃表。又由于链表结构的二叉搜索树会出现不平衡的情况，所以才需要AVL和RBT。

而跳跃表则是一种比较独特的解决方案，他通过建立多层的链表节点和高层节点对低层结点的引用（即索引），相当于给了链表二分随机访问（即访问中点）的一个机会，使得同样可以对链表进行随机访问式的二分查找。**最好的索引建立规则就是每两个结点就往上层建立一个索引节点，这样就能够对每一部分的中点都进行随机访问了。**那么这些捷径要如何建立呢，这要说到它的插入操作。

## 一、插入操作

插入时先根据高层的索引找到应该插入的最底层位置后，插入结点。然后用一个随机函数得到一个数字，根据这个数字决定将结点添加到第几层的索引中。随机函数的选择是非常有讲究的，从概率上讲，能够保证跳表的索引大小和数据大小平衡性，不至于性能的过度退化。

## 二、定义

1. 由很多层结构组成，level是通过一定的概率随机产生的；

2.  每一层都是一个有序的链表，默认是升序 ；

3.  最底层(Level 1)的链表包含所有元素；

4.  如果一个元素出现在Level i 的链表中，则它在Level i 之下的链表也都会出现； 

5.  每个节点包含两个指针，一个指向同一链表中的下一个元素，一个指向下面一层的元素。

6. 时间复杂度为O(log n),如果是两个结点就往上层建立一个索引节点那就是普通的二分查找;

   空间复杂度O(n),大概需要两倍结点

## 三、与AVL的比较

1. 在做范围查找的时候，平衡树比skiplist操作要复杂。平衡树需要以中序遍历的顺序继续寻找其它不超过大值的节点。skiplist进行范围查找非常简单，只需要在找到小值之后，对第1层链表进行若干步的遍历就可以实现。
2. 平衡树的插入和删除操作可能引发子树的调整，逻辑复杂，而skiplist的插入和删除只需要修改相邻节点的指针，操作简单又快速。
3. skiplist需要更少的指针内存。平均每个节点包含1.33个指针，比平衡树更有优势。
4. 从算法实现难度上来比较，skiplist比平衡树要简单得多。

> 参考资料
>
> https://blog.csdn.net/qpzkobe/article/details/80056807