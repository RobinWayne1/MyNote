# 基础架构概念

## 一、三大特点

* 消息系统： Kafka 和传统的消息系统（也称作消息中间件〉都具备系统解稿、冗余存 储、流量削峰、缓冲、异步通信、扩展性、 可恢复性等功能。与此同时， Kafka 还提 供了大多数消息系统难以实现的消息顺序性保障及回溯消费的功能。
* 存储系统： Kafka 把消息持久化到磁盘，相比于其他基于内存存储的系统而言，有效 地降低了数据丢失的风险。 也正是得益于 Kafka 的消息持久化功能和多副本机制，我 们可以把 Kafka 作为长期的数据存储系统来使用，只需要把对应的数据保留策略设置 为“永久”或启用主题的日志压缩功能即可。
* 流式处理平台： Kafka 不仅为每个流行的流式处理框架提供了可靠的数据来源，还提 供了一个完整的流式处理类库，比如窗口、连接、变换和聚合等各类操作。



## 二、架构

### Ⅰ、Producer：生产者

### Ⅱ、Consumer：消费者

### Ⅲ、Broker：服务代理节点

`Broker`相当于一个独立的Kafka节点,一个或多个`Broker`组成了Kafka集群。

### Ⅳ、Topic：主题

主题是一个逻辑上的概念，生产者将消息发送到某个主题中，消费者订阅这个主题则能够获取到消息，所以对于生产者和消费者来说，主题相当于消息存储的基本单位。

### ==Ⅴ、Partition：分区==

分区是这里最重要的概念。刚刚上面说到主题是一个逻辑上的概念，**因为对于Kafka来说，消息的存储单位是分区。一个主题可以有多个分区，而每个分区只属于一个主题。**

![](E:\Typora\MyNote\resources\Kafka\分区消息追加.png)

#### 1、有序性保证

分区在存储层面可以看成一个可追加的日志文件。消息在追加到分区日志文件时会分配一个偏移量（`offset`），==`offset`是消息在分区的唯一标识。**也就是说，Kafka只保证分区内的消息有序性。**==

#### 2、集群负载均衡

Kafka中的**分区可以分布在不同的`Broker`上**,也就是说一个`Topic`可以横跨多个`Broker`。**每一条消息在发送到`Broker`之前，都会根据分区规则选择存储到哪个分区，如果该主题分区在不同的`Broker`中,则可以达到负载均衡的目的。**

#### 3、高可用保证

##### ①、Kafka端

###### ₁、多副本机制

![](E:\Typora\MyNote\resources\Kafka\多副本架构.png)

==**Kafka为分区引入了多副本（Replica）机制。**==一个分区中的多个副本是一主多从的关系，并且各个副本之间的数据理论上是应该保持一致的。==其中主分区`leader`负责处理读写的请求,而从分区`follower`只负责同步`leader`的数据。副本处于不同的 broker 中==，**当 leader 副本出现故障时，从` follower` 副本中重新选举 新的 `leader` 副本对外提供服务。** Kafka 通过多副本机制实现了故障的自动转移，当 Kafka 集群中 某个 broker 失效时仍然能保证服务可用 。

###### ₂、故障转移机制

分区中所有副本称为AR（Assign Replicas），所有与leader副本保持一定程度同步的副本（包括leader副本）组成ISR（In-Sync Replicas），而与leader副本滞后过多的副本称作OSR（Out-of-Sync Replicas）。由此可见，AR=OSR+ISR。 

leader副本负责维护ISR集合中所有副本的滞后状态，当follower副本落后太多，那么leader副本就会将他从ISR中剔除到OSR；而如果follower重新追上了leader副本，那么leader副本就会将它从OSR重新加入ISR。**一般情况下，只有ISR中的副本才有资格被选为leader副本。**

###### ₃、主从复制机制

Kafka的主从复制涉及到两个概念：HW(High Watermark)与LEO(Log End Offset)。其中LEO是每个副本为维度的，而HW则是以所有ISR集合内的副本为维度的。==**其中LEO作用是标识当前副本日志文件中下一条待写入消息的 offset，而HW表示的就是当前*ISR集合*内的 *各副本的LEO最小值。***==在主从复制的过程中势必会有某些follower副本的复制跟不上leader副本的情况，而HW就是用来解决这种问题的。HW就代表着当前ISR集合内所有副本都有的消息 的最大offset，而Kafka也规定消费者只能消费HW这个offset之前的消息，这样对消费者来说就保证了主从复制的同步。

##### ②、客户端

Consumer 使用拉（Pull）模式从服务端拉取消息，**并且保存消费的具体位置**， 当消费者宕机**恢复上线时可以根据之前保存的消费位置重新拉取需要的消息进行消费，这样就不会造成消息丢失。**









