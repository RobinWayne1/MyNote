# 第三章 表

## 一、InnoDB逻辑存储结构

## 二、InnoDB行记录格式

#### 1、varchar

* varchar(n)的n指列存储的最大字符长度,超出部分会被MySQL丢弃

* ⭐Varchar()后的长度指的是字符的长度，而文档中说明VARCHAR类型最大支持65535，单位是字节。所以如果选择`CHARSET=UTF-8`时，字符长度最大可填65535/3=21845；所以如果选择`CHARSET=latin1`时，字符长度最大可填65535

* 并且65535指的是单表内所有VARCHAR列的长度总和，即总和不能超过65535

#### ⭐2、varchar与char的区别

* `varchar`比`char`更节省空间,因为`char(N)`一定会分配N个字符的空间,如果插入的字符串不足N个字符则使用空格代替;而`varchar`会根据插入的字符串大小分配空间(使用变长字段长度列表记录分配空间的多少)
* 在更新`varchar`列时会有额外的开销(因为要重新分配空间),更新`char`列不会
* char的最大长度是255字符;而varchar的最大长度是65535字节,需要根据具体的字符编码计算最大字符长度
* varchar查找效率较差,而char查找效率较高

## 三、InnoDB数据页结构

#### 1、⭐Page Directory(索引顺序文件的思想)

![](E:\Typora\resources\MySQL\微信截图_20191105162902.png)

InnoDB数据查找过程：

- 找到数据所在的页。这个查找过程就跟前面说到的 B+Tree 的搜索过程是一样的，从根结点开始查找一直到叶子结点。
- 在页内找具体的数据。读取第 1 步找到的叶子结点数据到内存中，然后通过==分块查找==的方法找到具体的数据。

而分块查找这个过程就要用到Page Directory。

左边蓝色区域称为 Page Directory，这块区域由多个 Slot 组成，是一个稀疏索引结构，即一个槽中可能包含多个记录。**==(n_owned指槽里含有多少数据)==(伪记录Infimum的n_owned值始终为1,而Supremum的n_owned值可以为1-7,其他槽的n_owned值为4-8)**

右边区域为数据区域，每一个槽中都包含多条行数据。**注意看图中最上面和最下面的两条特殊的行记录 Infimum 和 Supremum，这是两个虚拟的行记录。** **每个槽中最大的那条记录的 n_owned 才会有值，其他的用户记录的 n_owned 为 0。**

==**在页中查找数据的过程:**==

1. **首先在PageDirectory中通过二分查找找到数据对应的槽,例如要找"6"这条数据时,二分查找会来到"4"这个槽**
2. **通过链表的遍历直到找到数据**

## 四、分区表

* 水平分区：指将同一个表中不同行的记录分配到不同的物理文件中。

* 垂直分区：指将同一个表中不同列的记录分配到不同的物理文件中。

#### 1、分区和性能

分区时要注意：

* 在没有辅助索引的情况下，分完区之后的100W条数据可能 和没分区前的1000w条数据的B+树高度都是2，这样分区是没有意义的
* 利用 用来分区的索引 查询数据时InnoDB会根据数据所在分区而只扫描此分区的索引**(根据不同的分区策略的规则和对应的索引值找到所在分区,例如hash函数,这称为分区修剪)**，==**但是如果有利用 不是用来分区的索引 查询数据时，InnoDB将会搜寻所有分区(因为非分区的索引也被拆开了分别放进不同的ibd文件中，此时InnoDB就无法根据索引值找到对应分区)**==,极大降低性能