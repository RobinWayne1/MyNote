# 第四章 索引

## 一、B树和B+树

### ⭐1、B树定义(m为B树的阶数)

<img src="E:\Typora\resources\MySQL\B树.png" style="zoom:75%;" />

1. 根结点至少有两个子女；

2. 每个非根结点所包含的关键字个数 j 满足：┌m/2┐ - 1 <= j <= m - 1；

3. 除根结点以外的所有结点（不包括叶子结点）的度数(子结点个数)正好是关键字总数加1，故**内部子树**个数 k 满足：┌m/2┐ <= k <= m ；

4. 所有的叶子结点都位于同一层。

#### ①优点

1. B树主要的优点是相对于二叉树,每个结点包括更多的关键字,所以其树高相对较低,查找效率很高.
2. B树的每一个结点都包含key和value，因此经常访问的元素可能离根结点更近，因此访问也更迅速。

### 2、B+树定义

<img src="E:\Typora\resources\MySQL\B+树.png" style="zoom:67%;" />

1. B+树的索引项只包含对应子树的最大关键字和指向该子树的指针，不含有该关键字对应记录的存储地址。（即看起来是某结点和其子结点有相同的键）
2. **每个叶子结点都存有相邻叶子结点的指针，叶子结点本身依关键字的大小自小而大顺序链接**（范围查找特性）
3. 其他和B树相同

#### ①优点

1. B+树的层级更少：**相较于B树B+每个非叶子结点存储的关键字数更多(因为占用空间小,不存数据)**，树的层级更少所以查询数据更快；

2. B+树查询速度更稳定：B+所有关键字数据地址都存在叶子结点上，所以每次查找的次数都相同所以查询速度要比B树更稳定;

3. B+树天然具备排序功能：B+树所有的叶子结点数据构成了一个有序链表，在⭐==查询大小区间的数据时==候更方便，数据紧密性很高，缓存的命中率也会比B树高。

4. B+树全结点遍历更快：B+树遍历整棵树只需要遍历所有的叶子结点即可，，而不需要像B树一样需要对每一层进行遍历，这有利于数据库做全表扫描。
   

### 3、两者区别

1. ⭐B树中的所有结点都存储数据，而B+树只有叶子结点存储数据。若是像MySQL这种不断将结点页从磁盘移动到内存查找的话，B+树较B树较有优势且查询速度更稳定。因为B+数的非叶子结点页是索引页不存储数据，所以移动到内存的速度较快，递归查询到达叶子结点的速度就更快；而B树的非叶子结点包含数据，所以移动到内存的速度较慢，递归查询到叶子结点的速度就更慢。而大多数结点都是在叶子结点中的，所以就概率来说当然是前者较快。
2. B树中叶结点包含的关键字和其他结点包含的关键字是不重复的，而B+树是重复的

### 4、插入删除

和2-3-4树自底向上的合并删除和自底向上的分裂插入一样，EZ。

## 二、B+树索引

B+树索引在数据库的高扇出性特点，即树的高度一般都在2~4层，性能可观。

聚集索引与辅助索引不同点是：叶子结点存放的是否是一整行的信息和是否只用主键作为非叶子节点的key。

#### 1、聚集索引

InnoDB存储引擎表是索引组织表，即表中数据按照主键顺序存放，==而聚集索引就是**按照每张表的主键构造**一棵B+树(不指定主键时会默认产生一个ROWID主键)，同时叶子结点中存放的即为整张表的行记录数据，也将聚集索引的==叶结点==成为数据页。==**同B+树结构一样，每个数据页通过一个双向链表进行连接。由于实际的数据页只能按照一棵B+树进行排序，因此每张表只能拥有一个聚集索引。** (把页看成B+树的叶结点,页中的记录看成B+树叶子结点的记录）

优点:

* 可以把相关数据保存在一起，减少磁盘I/O。

* 访问数据更快。

* 使用索引覆盖扫描的查询可以直接使用叶结点中的主键值。

缺点：

* **==聚集索引最大限度地提高I/O密集型应用的性能，但如果数据都放在内存中，则访问顺序就没那么重要了，聚集索引也就没什么优势。==**
* 插入速度严重依赖插入顺序，如果是不连续的插入，容易导致页分裂和产生很多不会用到的磁盘空间(页内碎片)。
* 在某条记录插入到某个已满的页中,需要将这个页进行分裂,分裂之后会导致表占用更多的磁盘空间

#### 2、辅助索引

辅助索引的叶子结点并不包含行记录的全部数据，叶子结点除了包含该列的键值之外，还包含相应行数据的聚集索引键，方便InnoDB做回表查找时通过叶结点提供的主键值递归遍历聚集索引找到行记录所在的页位置。

**因为在二级索引的叶子结点==(也可以理解为非叶子结点也包含主键值)==包含了主键值,所以在列(A)上的索引就相当于在(A,ID)上的索引。**

优点：

* 在InnoDB中，==二级索引的叶子结点存储的是主键值而不是行指针==，这样的策略减少了当出现行移动或者数据页分裂时二级索引的维护操作，即不需要更新辅助索引的指针。

## 三、Cardinality

Cardinality是指选择性，即**某列不重复的记录数/数据表的总记录数**，若某个字段的取值范围很广，几乎没有重复，则该字段属于高选择性。只有对高选择性的字段做B+树索引才有意义，才能真正发挥索引作用。对低选择性的字段加索引和不加索引最终都是大量链表查找，索引并没有作用，还增加了插入时的负担。

## 四、B+树索引的使用

#### 1、索引覆盖

索引覆盖，即**辅助索引包含**所有需要查询的字段。(一个辅助索引可覆盖主键值和当前列的值)

**此索引可以结合联合索引一起使用，即增加不回表查询时返回的字段数量，从而不用回表查询提高性能**。

###### ①联合索引（聚集索引或辅助索引都可以是联合索引）

联合索引也是一棵B+树，不同的是联合索引的键值的数量不是1，而是大于等于2(即**(1,1)(1,2)(2,1)(2,4)(3,1)**这样排序)。

![](E:\Typora\resources\MySQL\2461473953-59aa454595b17_articlex.png)

可以看到，==**联合索引中的索引项会先根据第一个索引列进行排序，第一个索引列相同的情况下，会再按照第二个索引列进行排序(比较时也是如此)**==，依次类推。

因此，对于查询`SELECT * FROM TABLE WHERE a=XXX and b=XXX；`是可以使用联合索引的，`SELECT * FROM TABLE WHERE a=XXX；`也可以使用联合索引,但`SELECT * FROM TABLE WHERE b=XXX；`不可以使用,因为对于b列来说索引的顺序是乱序。

==**下面是联合索引的一些限制：**==

1. 如果`where`不是从索引的最左列开始查找，则无法使用索引。例如直接查找名字为Bill的人，或查找某个生日的人都无法应用到上面的索引，因为都跳过了索引的第一个列。此外查找姓以某个字母结尾的人，也无法使用到上面的索引。**(最左前缀原则)**

2. 不能在中间跳过索引中的某个列，例如不能查找姓为Smith，生日为某个特定日期的类。这样的查询只能使用到索引的第一列。

3. **==如果查询中有某个列的*范围查询*，则该列右边的所有列都无法使用索引优化查找。==**例如有查询

   `WHERE last_name='Smith' AND first_name LIKE 'J%' AND birth='1976-12-23'`，这个查询只能使用到索引的前两列，而不能使用整个索引。==(因为在检索到`LIKE "J%"`时所需要的数据就不能比较是在该索引结点的左边还是右边了)(如检索到某非叶子结点为(Smith,Jobs,1976-12-26),因为左右两边子树都有可能存在符合`“J%”`的数据,所以不能再用birth比较了;而如果索引结点为(Smith,ken,1976-12-26),此时还可以经过比较得到 比此索引结点小 ,从而检索左边数据,但还是用不到birth的索引)==

4. **MySQL不支持用索引搜索以通配符开头的LIKE查询**

<https://www.cnblogs.com/happyflyingpig/p/7662881.html>

其中的EXTRA：

Using index：表示使用索引覆盖

#### 2、自定义哈希索引

问题：某些字段很长(例如`select id from url where url="http://www.mysql.com";`),如果直接在字段上建索引则性能并不会很好.

解决方案:使用索引(url_crc),在插入时使用`CRC32`函数做哈希,则在select时使用`select id from url where url="http://www.mysql.com" and url_crc=CRC32("http://www.mysql.com")`(只使用了url_crc做索引扫描)。就算CRC10位的CRC函数值选择性不高，但是也足够过滤了大部分的数据。其中`url="http://www.mysql.com"`是为了处理哈希冲突。

#### 3、前缀索引

原理：如果某些列有比较长的值，此时就可以使用前缀索引。前缀索引的原理就是使得行的完整值可以用它的一部分前缀来唯一标识，而前缀长度的选择目的就是要追求用一个更小的前缀来标识列的值，如果前缀能标识的行越少，那么就说明该列的选择性越高，越能够直接找出数据而不用再次过滤，此时的索引就变小了，但是选择性却没有变，这就是优化了。

这是上一个问题的第二个解决方案：索引开始部分的字符，这样通常可以大大结约索引空间，从而提高索引效率。但是这会降低索引的选择性，如`url="http://www.mysql.com`,如果只截取前面部分字符,则索引选择性非常低,几乎过滤不了任何数据(可以将url反转存储截取前面部分字符，即后缀索引),**所以要根据表内的字段不断尝试出最好的前缀长度和选择性的权衡。**

对于BLOB、TEXT或者较长的VARCHAR类型的列必须使用前缀索引。

#### 4、利用索引扫描来做排序

==**⭐由于SQL的执行是`WHERE→ORDER BY`,所以只有当索引的列顺序和`1.WHERE 2.ORDER BY`这两者的列顺序一致时,**==并且所有列的`ORDER BY`排序方向（正序或倒序）都一样时，MySQL才能使用索引来对结果做排序。

##### ①、例一

```sql
--key: idx(rental_date,inventory_id,customer_id)
SELECT rental_id,staff_id FROM sakila.rental
WHERE rental_date='2005-05-25'
ORDER BY inventory_id,customer_id;
```

查找过程:InnoDB根据`rental_date`的值递归迭代idx,得到符合条件的数据后,由于在该索引中符合` rental_date='2005-05-25'`的`inventory_id,customer_id`列都是按升序排列的,所以可以直接使用索引来做排序

##### ②、例二

```sql
--key: idx(rental_date,inventory_id,customer_id)
SELECT rental_id,staff_id FROM sakila.rental
WHERE rental_date='2005-05-25' AND inventory_id IN(1,2)
ORDER BY customer_id;
```

查找过程:InnoDB根据`rental_date`和`inventory_id`的值递归迭代idx,得到符合条件的数据后,由于这些数据中`inventory_id=1`和`inventory_id=2`的`customer_id`并不完全是升序排列的,而是中间间断的升序,所以不能够用索引做排序

**==注：在判断是否可以用索引做排序时，想象一下SQL具体执行时会怎么走索引 就会判断了。==**

##### ③、特殊情况

(看不懂先看看本文最下面的GROUP BY规则)

```sql
explain 
SELECT 
	film.film_name  
FROM
	film
	JOIN ( SELECT film_id  FROM film_actor where film_id<5000 ) AS c USING(film_id)
	GROUP BY film_name;
```

排序时本应使用`idx_film_name（film_name，film_id）`的辅助索引**(即先处理外层查询查出所有（film_name，film_id）,再将外层查询join进子查询中,下图二第一行体现了这一点)**,然而如果不加`STRAIGHT_JOIN`的话,优化器会将子查询join进外层查询，此时排序就无法使用`（film_name，film_id）`索引了**⭐(因为子查询使用了`idx_fk_film_id2(film_id，film_actor_id)`索引进行嵌套关联，即子查询每查出一条记录，就会根据这条记录 进行连接的那列 从而 进行外层查询得到数据，这种嵌套连接时的查询 使用的索引就是连接那列的最左前缀，即(film_id),所以此时就必须用film表的聚集索引进行查询,从而无法使用索引做排序)**

![](E:\Typora\resources\MySQL\微信截图_20191123223134.png)

![](E:\Typora\resources\MySQL\微信截图_20191123222947.png)

#### 5、独立的列

“独立的列”指**==索引列==**==(只是索引列,并非值)==**不能是表达式的一部分，也不能是函数的参数**。如`where age+1=30`就不可使用索引。

#### 6、多列索引

MySQL在5.0和更新版本引入了一种叫“索引合并”的策略，一定程度上**可以使用表上的多个单列索引来定位指定的行。**原理：**在查询中同时对不同条件使用不同的单列索引进行扫描，并将结果进行合并。**

#### 6、建索引原则

基本原则：在没有特定业务需求的情况下(排列,分组)，将选择性最高的列放到索引最前列。

但是抛开业务需求一切都是扯淡，要先考虑**==搜索条件的频率==**和是否能用IN技巧在考虑选择性。因为索引不是建立给单个查询，而是建立给多个查询的，所以要先考虑**==一般情况下业务的DDL多数(大概率)会用到的字段==**,比如社交网站的sex字段,在用户过滤查询时,一般都会先选择性别,虽然它选择性极低,但是也要摆在第一位;如果摆在后面,有客户只想根据性别进行筛选就无法用到索引了(并且选择性低的字段一般可以用IN技巧跳过)。而比如last_name字段,虽然其选择性高,但是很少会用到且不能用IN技巧跳过最左原则,如果放在前面,其后的索引字段就很难用的上了。

#### 7、Multi-Range Read优化

![](E:\Typora\resources\MySQL\MRR1.png)

![](E:\Typora\resources\MySQL\MRR2.png)

MRR的工作方式:

1. 将查询得到的辅助索引键值存放于一个缓存中,这时缓存中的数据是**根据辅助索引键值排序的**。
2. 将缓存中的键值**根据RowId(主键)进行排序**。
3. 根据RowId的排序顺序来访问实际的数据文件。

MRR优化的好处：

1. MRR使数据访问变得较为顺序。

2. 减少缓冲池中页被替换的次数。**(若InnoDB的缓冲池不是足够大,不能存放下一张表的所有数据,此时频繁的离散读操作还会导致缓存中的页被替换出缓冲池,然后又不断地被读入缓冲池。==如果顺序访问则可以将重复降到最低==)**

3. 批量处理对键值的查询操作。(如`SELECT * FROM TABLE WHERE key_part1 >= 1000 AND key_part1 < 2000 AND key_part2 = 10000;`，表TABLE有联合索引(key_part1,key_part2)。

   若无MRR，此时的查询将会先将符合key_part1条件的数据全部取出,然后再根据key_part2条件过滤,这会导致无用数据取出。 

   启用了MRR，此时的查询会将条件拆分为(1000,10000)(1001,10000)(1002,10000)等,提升了性能)

#### 8、Index Condition Pushdown优化

简介:不支持ICP优化时，当进行索引查询，**首先根据索引来查找记录，然后在服务器曾再根据其他WHERE条件来过滤记录。在支持ICP后，MySQL会在取出索引的同时判断是否可以通过WHERE条件的过滤，再获取记录。**也就是将WHERE的部分过滤操作放在了存储引擎层。

关闭ICP的情况

![](E:\Typora\resources\MySQL\微信截图_20191123205442.png)

开启ICP的情况:

![](E:\Typora\resources\MySQL\微信截图_20191123205527.png)

⭐**ICP的作用对象是==`①`where条件中的字段有辅助索引==,但是有字段有范围查询条件（即`>,<,between,like`这几种条件）或查询条件没有符合最左前缀原则使得**==`②`有一部分`where`条件无法在存储引擎过滤结果**(若仅递归查询B+树得不到那些 符合某些条件的 数据,InnoDB就会将这些过滤工作交给服务器层)**==**,**此时就可以在InnoDB用ICP技术(实际就是给InnoDB提供了一定的不依赖索引的过滤能力)在要==进行`③`回表查之前==,将得到的主键映射 根据**本来要在服务器层过滤的`where`条件**先过滤一遍,之后再回表查,减少了磁盘I/O数据页的次数。

具体过程如下:

* 没有使用ICP时:

  * ①：MySQL Server发出读取数据的命令

  * ②③④⑤：进入存储引擎，读取辅助索引树，在辅助索引树上查找，把满足条件的（经过查找，红色的满足）从表记录(聚集索引)中读出（步骤④，通常有IO），从存储引擎返回⑤标识的结果。此处，不仅要在索引行进行索引读取（通常是内存中，速度快。步骤③），还要进行进行步骤④，通常有IO。
  * ⑥：从存储引擎返回查找到的多条元组给MySQL Server。
  * ⑦⑧：⑦到⑧依据WHERE子句条件进行过滤，得到满足条件的元组。**注意在MySQL Server层得到较多元组，然后才过滤，最终得到的是少量的、符合条件的元组。**

  


![](E:\Typora\resources\MySQL\99941-20160719113057888-330627393.png)

* 使用ICP后
  * ①：MySQL Server发出读取数据的命令，过程同图一。
  * ②③：进入存储引擎，读取辅助索引，在辅助索引树上查找满足一部分where条件的记录(经过查找，红色的满足）
  * ④⑤:**在回表查之前使用被下推的条件再对上一步得到的记录过滤一遍==*(注意:这里使用的是辅助索引字段的键值进行判断,即主键值也可以算在里面)*==,不满足条件的不读取数据页,这里则减少了许多磁盘I/O。**随后返回数据给服务器层。
  * ⑥⑦：从存储引擎返回查找到的完整符合条件的数据返回给MySQL Server,然后返回客户端。

![](E:\Typora\resources\MySQL\99941-20160719113114029-2069896261.png)

**⭐总结:实在是有点乱,还是来个总结把。**

在没有ICP时，MySQL对符合==使用辅助索引、并且查询语句中 部分对列的查询无法在InnoDB过滤结果、且需要回聚集索引查找的查询语句==的处理是：①在InnoDB先以可使用辅助索引的那部分查询语句的条件为key，递归遍历辅助索引筛选出符合这部分查询语句的辅助索引叶结点。②之后，根据这些叶结点的主键ID回表查出完整的行记录后，将这些行记录交给MySQL服务器层。③服务器层负责对这些行记录逐条比较，进行另外那部分无法依赖辅助索引过滤的查询语句的过滤。

很明显的一个优化方向就是，可以先在InnoDB层做完完整的辅助索引叶结点过滤后，再进行回查聚集索引，这样就减少了很多本来就不符合条件的记录的回表查，大量减少了回查聚集索引造成的磁盘IO。而ICP就是这样做的，给InnoDB赋予了一定的不依赖索引的过滤能力,将第三步要做的工作放在了InnoDB的第一步之后做了。

#### 9、不走索引的几种情况

1. 上面介绍的联合索引使用限制
2. 在字段`not null`的情况下，`is null`和`is not null`都不会走索引。因为`is null`是不可能情况;而`is not null`则是整张表的数据,所以是全表扫描
3. 如果条件中有or,则无法使用联合索引,最左前缀在or中不适用。InnoDB只会使用or两边的单列索引
4. 如果列类型是字符串，那一定要在条件中将数据使用引号引用起来,否则不使用索引（或使用索引的全表扫描）
5. 如果InnoDB估计使用全表扫描要比使用索引快,则不使用索引

## 五、全文检索

#### 1、倒排索引

* inverted file index
* full inverted index

具体看书

## 六、查询优化

#### 1、查询执行路径

<img src="E:\Typora\resources\MySQL\查询执行路径.png" style="zoom:80%;" />

1. 客户端发送一条查询给服务器
2. 服务器先检查查询缓存，如果命中了缓存，则立刻返回存储在缓存中的结果（mysql8删除了查询缓存）。否则进入下一阶段。
3. 服务器端进行SQL解析、预处理（检查解析后生成的解析树是否合法 ），再由优化器生成对应的执行计划。
4. mysql根据优化器生成的执行计划，调用存储引擎的api来执行查询
5. 将结果返回给客户端。

#### 2、EXPLAIN解析

<img src="E:\Typora\resources\MySQL\explain讲解.png" style="zoom:60%;" />

①、`id`

id的含义是标识该查询所属的部分。如果在语句当中有子查询或联合,就会出现不同的ID,子查询或联合就是不同的所属部分。

②、`select_type`

此列显示了对应查询所属部分是简单还是复杂SELECT。

* `Simple`取值意味着此次查询不包括子查询和UNION

* `PRIMARY`意味着该查询中有复杂的 其它 子部分   
  <img src="E:\Typora\resources\MySQL\explain讲解2.png" style="zoom:60%;" />
  
  ```sql
  explain 
  SELECT 
  	film.film_name  
  FROM
  	film
  	JOIN ( SELECT film_id  FROM film_actor where film_id<5000 ) AS c USING(film_id)
  	GROUP BY film_name;
  ```
  
  * 其他部分取值为`DERIVED`则表示 包含在`FROM`子句的子查询中的`SELECT`,如上面这个例子就是使用了`STRAIGHT JOIN`的嵌套关联，其 位于第二行的 `<derived2>`表示的就是根据第一行外层查询得出的`film_id`,嵌套查找符合这些`film_id`的 (子查询得出的)子表数据
  
  * 在有`UNION`的查询中,写在`UNION`后的`SELECT`查询将会被标记为`UNION`,含义是 将之前部分（执行计划中在此之前执行的那部分）查询得到的数据与当前要查询的部分数据进行UNION
    ```sql
    (SELECT * FROM film_actor where film_id<100)
    UNION ALL
    (SELECT * FROM film_actor where film_id<200);--这句的select_type会被标记为UNION
    ```


**⭐注:总之看复杂的查询执行时,要知道除了出现特殊的子查询`<derivedN>`外,执行计划中的执行顺序就是从上往下看下来**

③、`table`

此列的含义就是对哪张表进行查询。

* 特殊情况：table列是`<derivedN>`的形式,其中N是子查询的ID,此时的`table`含义就是引用某子查询产生的临时表。

④、`type`

此列表示MySQL决定如何查找表中的行。

* `ALL`:意味着这部分查询将会==全表扫描==
* `index`:依旧是==全表扫描==,只不过这种扫描是按主键顺序的扫描,避免排序.注意与`EXTRA`的`USING INDEX`区分开来
* `range`:即**有限制的**==索引扫描==,如带有`BETWEEN`或在`WHERE`子句中带有>的查询就是范围扫描.
* `ref`:即返回**所有匹配某个单个值**的行,是一种==索引扫描.==称作`ref`是因为索引要与某个参考值作比较。
* `eq_ref`:MySQL检测出这部分查找**只会返回一条记录**,是一种==索引扫描==。与`ref`的区别是,`eq_ref`只会返回一条行记录,并且MySQL对这种查询做足了优化;而`ref`会返回任意条记录,并没有过多优化。

⑤、`rows`

此列表示MySQL估计为了找到所需的行而要读取的行数.

⑥、`Extra`

这列表示的是查询的额外信息。

* `Using index`:此值代表MySQL将使用索引覆盖以避免访问索引组织表。
* `Using where`:此值代表 存储引擎根据查询语句给定的**一部分条件**检索完行之后,由MySQL服务器将 存储引擎检索完的行 根据剩下的一部分条件再检索一遍。出现此值的原因大多数都是因为有部分`WHERE`的条件无法使用存储引擎的索引,所以才要交给服务器层做检索。
* `Using index condition`:将上面所说的交给MySQL服务器做的检索下推到存储引擎层做。
* `Using temporary`:意味着MySQL在对**查询结果排序时**会使用一个临时表
* `Using filesort`:意味着MySQL会对结果使用外部索引排序,而不是按 内部早创建好的的索引次序从表里读取行。出现`filesort`就要看一下能不能创建一个索引以使得查询可以用索引做排序。

#### 3、重构查询

##### ①、分解关联查询

在《阿里开发手册》中说到，不能同时对三张表做join操作。

但如果能将这三张表的关联查询在后台分解开**（即需要`inner join`三张表时,可以用一条`select`查出第一个表的行数据,再用行数据的关联字段查第二张表的行数据,再用第二张表行数据的关联字段查第三张表**）来,虽然增加了后台拼接和三倍网络I/O的时间(也不是三倍),但是可以有以下优点:

* 让缓存的效率更高。可以在后台与数据库中间建立一个缓存数据库，而将关联查询分解后就可以同时对三个单表查询做缓存，让其他业务DDL也可以利用缓存结果，跳过某次查询。
* 减少锁竞争。
* 更容易对数据库进行拆分，更容易做到高性能和可扩展。

#### 4、查询优化处理

##### ①、查询优化器

* **提前终止查询**。在发现已经满足查询需求的时候，MySQL能够立刻终止查询，例如使用LIMIT子句。讲limit 1
* 列表IN()的比较。对于查询语句中有`IN()`的情况,InnoDB会先对IN()列表中的数据进行排序，然后再比较行数据时使用二分查找的办法确定列表中的值是否满足条件。==但是如果IN中的是临时表，EXPLAIN就会提示使用了临时表自动生成的索引(mysql5.6),暂时不清楚哪种是正确的。==

##### ②、MySQL如何执行关联查询

MySQL认为任何一个查询都是一次关联，而不仅仅是一个查询需要用到两个表匹配(join)才叫关联，即包括子查询，单表的select**(IN也属于join的一种)**都可能是关联。

关联执行的策略：嵌套循环关联，即现在一个表中循环取出单条数据，然后再嵌套循环到下一个表中寻找匹配**（注意这个嵌套查找同样会使用索引）**的行(深搜+回溯+遍历)

==**注：循环关联操作是要看优化器选择哪张表join哪张表，而不是一定为select的表join关联的表。此即为关联查询优化器，在关联顺序中选择一个成本最小的来生成执行计划树。例子为p219。**==

##### ③sql语句的执行顺序

**`from`→`where`→`group by`→`having`→`select(包括聚合函数)`→`order by`**

#### 5、MySQL查询优化器的局限性

##### ①、UNION的限制

可以先看[前置知识](#⑤优化UNION查询)。

如果要对UNION子句做一个全局LIMIT，建议先在子句中做一个与全局LIMIT值相等的LIMIT

如此SQL:

```sql
(SELEC first_name,last_name FROM
 sakila.actor
ORDER BY  last_name)
UNION ALL
(SELEC first_name,last_name FROM
 sakila.customer
ORDER BY  last_name)
LIMIT 20;
```

这条查询会将两个表中的所有数据先查出来,组成一个临时表后,再取出临时表中的前20条记录。**很明显没有必要组成这么大的一个临时表**，现解决如下：

```sql
(SELEC first_name,last_name FROM
 sakila.actor
ORDER BY  last_name
LIMIT 20)
UNION ALL
(SELEC first_name,last_name FROM
 sakila.customer
ORDER BY  last_name
LIMIT 20)
LIMIT 20
```

由于只需要 两查询组合后的前20条数据,所以分别**先**给两个查询做limit,就可以大大降低临时表占用的空间。

##### ②、最大值和最小值优化

如果在**where条件中的字段没有索引**，MySQL会做全表扫描导致就算得到了MIN()符合的值（如要得到最小的递增列的值）也还是会继续扫描下去

#### 6、优化特定类型查询

##### ①、优化COUNT()

###### Ⅰ、COUNT()的两种作用

它的两种作用是：可以统计某个列值的数量，也可以统计行数。

* 统计列值的数量：`count(column)`,统计列值时不会统计null
  
  * 统计列中不同值的个数：`count(distinct column)`
  * 这里注意一下`count(distinct column)`和`count(1) group by column `的区别:
    * 前者是执行完`distinct column`后再执行`count()`,这个count统计的是分组的个数
    * 而后者是在执行完`group by`后,再对每个分组的colomn值的行数进行`count()`统计,重点注意这个count统计的是整个表而不是分组个数
  
* 统计行数:`count(1)`或`count(*)`,统计表内的行数。

###### Ⅱ、优化

如果需要的数值不需要太准确，那就可以使用执行计划中的`rows`代替`count()`,因为EXPLAIN并不需要真正执行查询,所以成本很低。

##### ②、GROUP BY和DISTINCT

书里面讲的没有体会到有什么用。

* 当查询使用GROUP BY子句的时候，**==结果集会自动按照分组的字段进行排序==**，如果不关心排序可以使用ORDER BY NULL让MySQL不进行filesort

##### ==**③、优化LIMIT分页**==

MySQL对于`select`、`where`和`limit`的执行顺序是:`where`→`select`→`limit`。（通过这个顺序讲讲最左前缀原则）

正是这种顺序使得MySQL要查找比较靠后的一组数据时，如

```sql
SELECT * FROM  film_actor LIMIT 999970,30;
```

,会先使用全表扫描将`OFFSET`的行数据全都搬到内存扫描一遍后,再取出`OFFSET`的后10行。（这也是无奈之举，因为行数有时候并不能与行记录中的某列绑定，所以才需要全表扫描）

基于此出现了三种优化方法:

###### Ⅰ、没有列是递增列且 递增列的值含义与行数含义不同（其中递增列的值含义不同意思是该递增列并不能代表行数）

这个优化方法的思想是减少 从磁盘移动到内存的页数据,**即`LIMIT`需要做全表扫描时,扫描辅助索引而不是聚集索引**,这就能减少磁盘IO。

此时就使用索引覆盖的延迟关联。

```sql
--索引：idx_fk_actor_id(actor_id,film_actor_id);PRIMARY(film_actor_id,actor_id,film_id,····)
SELECT	* 
FROM film_actor
INNER JOIN ( SELECT film_actor_id FROM film_actor LIMIT 999970, 30 ) AS TEMP USING ( film_actor_id );
```

首先说明，就算子查询中不符合`idx_fk_actor_id`的最左前缀原则(没有从最左列开始查找),但是`LIMIT`必须要全表扫,所以符不符合最左前缀原则,优化器都会选择`idx_fk_actor_id`索引。如下图测试所示，

<img src="E:\Typora\resources\MySQL\limit分页1测试.png" style="zoom:60%;" />

在这个sql中，执行计划表明会先进行子查询，**子查询是利用辅助索引的全索引扫描（即执行计划`type`为`index`）并取出了 所需的30条`film_actor_id`，之后再根据这30条`film_actor_id`回表查得出完整的记录。**==这就是延迟关联,含义就是延迟对某些只在聚簇索引中的列的访问。==

###### Ⅱ、有列是递增列且该列值的含义与行数含义相同

列值含义与行数含义相同意味着此表不能够有删除的行。

这种情况就可以直接用递增列代表行数。

<img src="E:\Typora\resources\MySQL\limit分页2测试.png" style="zoom:60%;" />

利用以`(film_actor_id,··)`为开头的联合索引（这个例子直接用了聚集索引，如果使用的是联合辅助索引的话当然还要考虑回表查的问题）就可直接定位数据。

###### Ⅲ、有列是递增列但该列值的含义与行数含义不同

列值含义与行数含义不同意味着该表有删除了的行。

这种方法的思路是：分页只能前后两页的翻页，不能够跨页跳转。在前端记录好某一页的第一条记录的递增列值和最后一条记录的递增列值，如果用户想向后翻页，此时就将当前页的最后一条记录的递增列值传给后端；用户想向前翻页，就将当前页的第一条记录的递增列值传给后端。

从第一百万条记录向前翻页:

<img src="E:\Typora\resources\MySQL\limit分页3.11测试.png" style="zoom:60%;" />

<img src="E:\Typora\resources\MySQL\limit分页3.1测试.png" style="zoom:60%;" />

⭐注:虽然理论上会先`where`扫描前100万条记录再执行`limit`截取后30条记录,但是我估计这里MySQL有优化==(说的就是[查询优化器的提前终止查询](#①、查询优化器))==,因为在测试中的 向前翻页会扫描100万条记录竟然和向后翻页会扫描1000条记录的执行时间相同,都是0.02s。

从第999970条记录向后翻页:

<img src="E:\Typora\resources\MySQL\limit分页3.21测试.png" style="zoom:60%;" />

<img src="E:\Typora\resources\MySQL\limit分页3.2测试.png" style="zoom:60%;" />

和[第二种方法一样](#Ⅱ、有列是递增列且该列值的含义与行数含义相同),都是可以利用索引直接定位数据,只不过请求翻页时要用POST请求,不让用户瞎鸡儿改传输的行记录。

##### ④优化关联查询

==一定要确保`JOIN`的第二张表中有关联列的索引,即把关联列当成对第二张表的查询的一个`where`条件，之后就确保对第二张表的查询符合最左前缀原则即可。==

##### ⑤优化UNION查询

先说明一下`UNION`和`UNION ALL`的区别

* `UNION`:`UNION`是对多个结果集做并集操作,且会对做完并集操作产生的临时表加上`DISTINCT`选项去重,并且会按照字段的顺序进行排序
* `UNION ALL`:`UNION ALL`只是单纯的将多个结果集做一个合并,没有`UNION`的后面两步操作。

当不需要排序和去重时，一定要使用`UNION ALL`!

### 七、什么时候才使用索引

索引的建立意味着增删改的同时需要修改多个索引中的数据,使得操作变慢。所以只有当索引帮助存储引擎快速查找到记录带来的好处大于其带来的额外工作时，索引才是有效的。