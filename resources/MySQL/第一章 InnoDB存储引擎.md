# 第一章 InnoDB存储引擎

## 一.InnoDB体系结构

### 1.后台线程

* Master Thread
* IO Thread
* Purge Thread
* Page Cleaner Thread

### 2.内存

![](E:\Typora\resources\MySQL\InnoDB内存结构.png)

#### (一)缓冲池

在数据库中进行读取页的操作,==首先将从磁盘读到的页存放在缓冲池中==,这个过程称为将页"FIX"在缓冲池中.==下一次再读相同的页时,首先判断该页是否在缓冲池中.若在缓冲池中,称该页在缓冲池中被命中,直接读取该页.否则,读取磁盘上的页.==

#### (二)LRU List,Free List和Flush List

##### ①LRU List

最频繁使用的页在LRU列表的前端,而最少使用的页在LRU列表的尾端.**当缓冲池不能存放新读取到的页时,将首先释放LRU列表中尾端的页.**

> 新读取到的页，虽然是最新访问的页，但并不是直接放入到LRU列表的首部，而是放入到LRU列表的midpoint位置，把midpoint之后的列表(包括midpoint)成为old列表，之前的列表成为new列表。**而midpoint被再次读取时(第二次读取时)，需要等待 `innodb_old_blocks_time` 后才会被加入到LRU列表的热端**
>
> 解决的问题：某些SQL操作可能会使缓冲池中的热点页被刷出，影响缓冲池的效率(如全表扫描)，这些操作需要访问许多页，而这些页通常仅仅在这次查询操作中需要，并不是活跃的热点数据。**如果页被放入LRU列表的首部，那么有可能所需要的热点数据页从LRU列表中移除。**

##### ②Free List

当数据库刚启动时,LRU列表时空的,即没有任何的页。这时页都存放在Free列表中，当需要从缓冲池中分页时，首先从Free列表中查找是否有可用的空闲页，**若有则将该页从Free列表中删除，放入到LRU列表中；否则，根据LRU算法淘汰LRU列表末尾的页，将该内存空间分配给新的页**

##### ③Flush List

在LRU列表中的页被修改后，称该页为脏页，即缓冲池中的页和磁盘上的页的数据产生了不一致。这时数据库会通过CHECKPOINT机制将脏页刷新会磁盘，而Flush列表中的页即为脏页列表。**需要注意的是，脏页既存在于LRU列表中，也存在于FLUSH列表中。LRU列表用来管理缓冲池中页的==可用性==，Flush列表用来管理==将页刷新会磁盘==，两者互不影响**

#### (三)==重做日志缓冲==

InnoDB存储引擎首先将重做日志信息先放入到这个缓冲区,然后按一定频率将其刷新到重做日志文件

* Master Thread每一秒将重做日志缓冲刷新到重做日志文件；

* **==每个事务提交时会将重做日志缓冲刷新到重做日志文件，具体要看下面参数设置==**

  * innodb_flush_log_at_trx_commit控制在提交操作时,处理重做日志的方式:

    ​														 0:不将事务的缓冲写入磁盘上的重做日志,而是等待主线程每秒刷新

    ​				**不懂看redis笔记**            1:表示在执行commit时将重做日志缓冲同步写到磁盘,即调用fsync

    ​														 2:表示将重做日志异步写到磁盘,即调用write,因此不能保证执行commit时肯定会写入重做日志文件

* 当重做日志缓冲池剩余空间小于1/2时，重做日志缓冲刷新到重做日志文件；

### 3.Checkpoint

LSN(Log Sequence Number)代表版本.

#### （一）Checkpoint解决的问题：

* 减少数据库恢复时间(减少恢复的数据，这是基于重做日志无限大的情况，没有Checkpoint如果宕机则需要所有以前的重做日志恢复数据库)
* 缓冲池不够用时将脏页刷新到磁盘
* 重做日志不可用时(不可被覆盖)，刷新脏页到磁盘**(在数据库恢复过程中需要用到重做日志文件的某部分，此时这部分重做日志不可被覆盖，若没有其他可覆盖的重做日志（即没空间存放重做日志了），所以要将此时间段新的脏页直接刷新到磁盘，这项刷新操作由`Async/Sync Flush Checkpoint`完成)** 

#### （二）Checkpoint种类

* Sharp Checkpoint
  *  Sharp Checkpoint发生在数据库关闭时将所有的脏页刷新回磁盘
* Fuzzy Checkpoint
  * Master Thread Checkpoint
    * 以每秒或每十秒的速度从缓冲池的脏页列表中刷新一定比例的页回磁盘
  * FLUSH_LRU_LIST Checkpoint
    * innodb引擎检查Free列表中是否有足够的可用空间操作发生在用户查询线程中(100个空闲页),如果没有则会将LRU列表尾端的页删除,**而其中如果有脏页则要进行checkpoint刷新**
  * Async/Sync Flush Checkpoint
    * 检查重做日志版本领先磁盘数据版本多少(太多则重做日志就不可复用了),达到一定数值用checkpoint将脏页(从flush list选取)刷新到磁盘
  * Dirty Page too much Checkpoint
    * 脏页数据太多,Innodb强制进行Checkpoint,目的还是为了保存缓冲池中有足够可用的页

### 4.Master Thread

### ==5.InnoDB关键特性==

#### (一)插入缓冲

##### ①Insert Buffer

问题:插入行数据时,如果主键是自动递增的,聚集索引数据的插入则会很快,如在插入一条数据时发现缓冲池中没有此行应在的页,于是从磁盘中读取该页进缓冲池中往该页插入行(注:磁盘的预读机制会使得不仅仅读该页进内存,而是该页后的连续几页也会读进内存);此时若又插入第二条数据,由于聚集索引叶子节点根据主键排序且主键递增,该行应插入的页就落到了第一次插入时读取进来的页中,就可以直接往该页中插入,不需要再次读取磁盘。然而大多数情况下还要插入二级索引数据，由于 二级索引的B+树叶子结点值根据 非主键列进行排序，而每次插入的非主键列是由用户决定的,并不是单调递增的(如住址),所以第二次插入时就有大概率用不上第一次插入时读入的页,需要再次去磁盘中随机读取。==(即会不断遍历B+树,从而不断读取很多页,时间主要消耗在了多次寻道和旋转延迟,而且也浪费了磁盘的预读,因为插入的值是离散的,预读没有任何作用)==

解决方案：对于非聚集索引的插入和更新操作，不是每一次直接插入到索引页中，而是先判断插入的非聚集索引页是否在缓冲池中，若在，直接插入(这样不会读磁盘)；若不在，则先放入到Insert Buffer中，==**然后再以一定的频率和情况进行buffer和非聚集索引页的merge操作，这时通常能将多个插入合并到一个操作中(因为在一个索引页)**==

Insert Buffer用一棵全局B+树存储非聚集索引,其非叶子节点存储的key是`表空间id(每个表唯一拥有)和页所在表空间的偏移量offset`的组合,叶子节点存储的value是`插入的包含辅助索引列的行记录`，并且用`Insert Buffer Bitmap`记录辅助索引页剩余空间,保证merge(将`Insert Buffer`树的记录合并到辅助索引页上)时辅助索引页有足够的空间存放新插入的辅助索引记录。

##### ②Merge

操作发生的情况：

* 辅助索引页被读取到缓冲池时**(如进行SELECT时，索引页被读到缓冲池，这时会检查Insert Buffer确认该辅助索引页是否有记录存放于此，若有，则进行merge)**
* Insert Buffer Bitmap页追踪到该辅助索引页已无可用空间时(**?????**)
* Master Thread

#### (二)两次写

问题:当数据库发生宕机时,可能InnoDB存储引擎正在写入某个页到表中,而这个页只写了一部分,比如16kb的页只写了前4kb,这称为部分写失效。==因为脏页刷新到磁盘的写入单元小于单个页的大小，如果在写入过程中数据库突然宕机，可能会使数据页的写入不完整，造成数据页的损坏。而redo log中记录的是对页的**物理操作,即重做日志文件记录的是每个页的更改的物理情况(如记录偏移量800写"aaa"记录),如果数据页内部发生损坏了(MySQL在恢复的过程中检查page的checksum，checksum就是检查page的最后事务号，发生partial page write问题时，page已经损坏，找不到该page中的事务号。在InnoDB看来，这样的数据页是无法通过checksum验证的，就无法恢复。)，通过redo log也无法进行恢复。**==所以这种情况发生时,先通过页的副本还原该页(变为损坏之前),然后再进行重做。

![](E:\Typora\resources\MySQL\两次写流程.jpg)

解决方案：当一系列机制（Master Thread触发、checkpoint等）触发数据缓冲池中的脏页进行刷新到数据文件的时候，并不直接写磁盘，而是会通过memcpy函数将脏页**①先复制到内存中的double write buffer**，之后**②通过double write buffer再分两次、每次1MB顺序写入共享表空间的物理磁盘上**。**③然后马上调用fsync函数，同步脏页进磁盘上**。

若在`fsync`时系统宕机,恢复过程如下:

1. 使用磁盘中的`double write`数据对数据文件中损坏的数据页进行修复

2. 当数据文件回到一个正确的状态后,使用重做日志恢复因为宕机而在缓冲池中丢失的数据页

**请注意:`Doublewrite buffer`中的数据页只是缓冲池中脏页的一部分,并不是所有脏页,所以需要使用重做日志恢复不在`Doublewrite buffer`且丢失了的脏页。double write用作恢复由于宕机致使 写入数据文件损毁 的数据页，重做日志用作恢复未写入数据文件但在内存中丢失了的数据页**

#### (三)自适应哈希索引

　Innodb存储引擎会监控对表上索引页的查找，如果发现某索引页被频繁访问(最近连续被访问三次的数据)，则对该热点页建立哈希索引。建立哈希索引后不需要经过B+树3~4次的索引访问，只需要通过hash索引一次访问就可以得知目标页了。

#### (四)异步IO

MySQL使用异步IO处理请求。

#### (五)刷新邻近页

