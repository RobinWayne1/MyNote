# MVCC实现机制

**InnoDB的MVCC，是通过在每行记录后面保存两个隐藏的列来实现的。**

这两个列，一个保存了行的创建时间，一个保存了行的过期时间（删除时间）。当然存储的并不是实际时间，而是**系统版本号**（system version number）。**==(这里讲的跟坨屎一样,行的创建时间即被修改版本号,行的删除时间即为被删除版本号)==**==每开始一个新的事务，系统版本号都会自动递增。==**事务开始时刻的系统版本号会作为事务的版本号，用来和查询到的每行记录的版本号进行比较。** ==**(注意事务版本号只是用来比较的,而不是用来给行版本号赋值的!!,真正赋值的是系统版本号)**==

下面看一下在REPEATABLE READ隔离级别下，MVCC具体是如何操作的。

#### SELECT

InnoDB 会根据以下两个条件检查每行记录：

1. InnoDB只查找被修改版本号早于当前事务版本号的数据行（也就是，行的被修改版本号小于或等于事务版本号），**这样可以确保事务读取的行，要么是在事务开始前已经存在的，要么是事务自身插入或者修改过的。**
2. **行的被删除版本号要么未定义，要么大于当前事务版本号。==行的删除版本号如果没有被定义,说明该行没有被删除过;如果删除版本号大于当前事务的事务号,说明该行是被该事务后面启动的事务删除的,由于是repeatable read隔离等级,*后开始的事务对数据的影响不应该被先开始的事务看见*,所以该行应该被返回.==**

只有符合上述两个条件的记录，才能返回作为查询结果。

#### INSERT

InnoDB为新插入的每一行**==保存当前系统版本号作为行版本号==**。***(看清楚不是保存事务版本号,如果是事务版本号就出错了!!!)***

#### DELETE

对于删除,innodb直接==**把该行的*被删除版本号*设置为当前的系统版本号**==,相当于标记为删除,而不是实际删除

#### UPDATE

InnoDB为插入一行新记录，保存当前系统版本号作为行版本号，同时保存当前系统版本号到原来的行作为行删除标识。



![](E:\Typora\resources\MySQL\2100026-19f3a841076a7140.png)

**undo segment内的record即为update undo log record,如果select的时候不符合上述的条件1,会根据指针db_roll_ptr来到undo log链表对比trx_id(即为被修改版本号),找到版本号最新的且不大于事务版本号的数据返回。所以，update undo log在commit时才不可以被立即删除，而insert undo log只需要判断行记录中的被修改版本即可做到事务隔离，所以可在commit时立即删除。**

其中事务版本号只是一个描述，实际实现是有一个read view的数据结构，

* low_limit_id：某行记录的db_trx_id < 该值，则该行对于当前Read View是一定可见的

* up_limit_id：某行记录的db_trx_id >= 该值，则该行对于当前read view是一定不可见的

* low_limit_no：用于purge操作的判断

* rw_trx_ids：读写事务数组

REPEATABLE READ隔离级别下事务开始后使用MVCC机制进行读取时，会将当时活动的事务id记录下来，记录到Read View中。**READ COMMITTED隔离级别下则是每次读取时都创建一个新的Read View。**

⭐read view表示的是事务开始时MySQL还有哪些事务在执行，就应该为{596,597,598,599}集合的子集，假设为{596，598}，==整篇文章需要修改==<http://ju.outofmemory.cn/entry/99676>