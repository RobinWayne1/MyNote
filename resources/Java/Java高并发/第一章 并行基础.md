# 第一章 并行基础

### 一.必须知道的概念

#### 1.同步和异步

* 同步方法调用一旦开始，调用者必须等到方法执行结束返回后，才能继续后续的行为，而这种等待往往就意味着阻塞。
* 异步方法调用更像一个消息传递，一旦开始，方法调用就会立即开始返回，调用者就可以继续后续的操作。由于异步方法调用不需要等待方法执行完成，所以这也就意味着非阻塞。

#### 2.并发和并行

* 并发为多个任务交替执行
* 并行为真正意义上的“同时执行”

#### 3.临界区

临界区用来表示一种共享数据，可以被多个线程使用。但是每一次只能有一个线程使用它，一旦临界区资源被占领，其他线程要想使用这个资源就必须等待。

#### 4.死锁、饥饿和活锁

* 死锁：所有线程都在循环等待其他进程手里的资源
* 活锁：指的是任务没有阻塞，但是由于某些条件的不满足使得任务一直重试且一直失败，浪费系统资源的过程
* 饥饿：由于其他任务一直占用资源，从而导致当前任务无法获得所需要的资源而一直无法运行。可以说一下读写锁。

### 二、并发级别(阻塞、无饥饿、无障碍、无锁、无等待)

#### 1.无障碍

两个线程可以无障碍执行，不会因为临界区问题导致一方挂起。但如果一起修改共享数据，一旦检测到这种情况，他就会立即对自己所做的修改进行回滚，确保数据安全。但是多个线程不断回滚自己的操作时，则没有一个能走出临界区。

#### 2.无锁

无锁的情况下，所有的线程都能尝试对临界区进行访问，但不同的是，？？？==**无锁的并发保证必然有一个线程能够在有限步内完成操作离开隔离区**==？？？。**无锁的并行总能保证有一个线程可以胜出**，对于竞争失败的线程，他们必须不断重试直到获胜，如果总是尝试不成功，则会出现类似饥饿的现象，线程会停止。

### 3.无等待

每个线程最终都会运行，不会有饥饿的情况发生。

### 三、JMM

JMM的关键技术点都是围绕着多线程的原子性、可见性和有序性来建立的。

#### 1.原子性

多个线程一起执行的时候，一个操作一旦开始，就不会被其他线程干扰

**注**：对于32位的JVM来说，如果有多个线程同时对long(64位)型变量赋值，则该操作会出现错误，原因是32位JVM一次处理32位数据，没有控制对64位变量赋值的原子性。

#### 2.可见性

可见性是指一个线程修改了某一个共享变量值时，其他线程是否能够立即知道这个修改。

**例子** 由于编译器优化或者硬件优化的缘故，CPU1上的线程将变量t进行优化，将其缓存在cache中。如果CPU2修改了变量t的实际值，CPU1上的线程没有意识到改动则依然会读取cache里的值。

#### ==3.有序性==

##### (1)有序性定义

有序性是指程序在执行时，可能会进行指令重排，重排后的指令与原指令的顺序未必一致，从而造成的数据不一致。**即在一个线程中观察另外一个线程的变量，他们的值是否能观察到何时能观测到是没有保证的。**

==比如线程1方法中写着先声明了变量a后声明了变量b，但是从线程2看是不能从 可以观测到变量b的值 从而推出变量a有值的==

==**注：指令重排不会使串行的语义逻辑发生问题。**==

##### (2)指令重排

汇编指令的执行每一步都可能使用不同的硬件完成，比如取指令用PC寄存器和存储器，译码用到指令寄存器组，访问存储器等操作，所以才发明了流水线技术，**即多条指令在 其自身所涉及的 不同的硬件中同时进行操作，使得硬件利用率最大化。**

例子： LW R1,B       IF   ID  EX  MEM  WB

​			 LW R2,C			  IF  ID  EX  MEM  WB

​			 ADD R3,R1,R2          IF  ID     X       EX  MEM  WB   

​			 SW A,R3                          IF      ID     X    EX       MEM   WB     

其中IF为取指令，ID取寄存器操作数，EX为执行，MEM为存储器访问，写会WB

==X表示中断，原因则为上一步的ID去操作数还没准备好，ADD操作需要等待一步，由于这个延迟使得SW操作也要慢一拍。**即中断了流水线。**==

为了尽量减少流水线中断，这就产生了指令重排技术，例如有时在指令中(比如ADD指令)要等待上一步的操作数时，如果在ADD指令之后有要声明的变量，则先放到ADD前面执行，如下

 			LW R1,B       IF   ID  EX  MEM  WB

​			 LW R2,C			  IF  ID  EX  MEM  WB

​			 **LW R4,D					 IF  ID  EX  MEM  WB**

​			 ADD R3,R1,R2          	   IF  ID     (X)EX  MEM  WB   

​			 SW A,R3                          		IF      ID     (X)EX       MEM   WB     

这样就合理利用好了硬件，不会造成延迟，大大提升性能。