# 第二章 Java并行程序基础

## 一、线程基本操作 

### ==1.线程的创建和使用==

<img src="E:\Typora\resources\Java\Java高并发\Thread.png" style="zoom:50%;" />

由上图可知,Thread实现了Runnable,Runnable只有一个接口方法就是`run()`

```java
@Override
    public void run() {
        if (target != null) {
            target.run();
        }
    }
```

其中的target指的是成员变量`private Runnable target;`。而这个成员变量是在构造函数中调用`init()`方法根据传参进行初始化的,所以就产生了两种创建线程的方法

* 一种则是创建 直接继承Thread类 的MyThread类 的对象,并将`run()`方法覆盖,使用时就可直接调用父类`Thread.start()`执行`MyThread.run()`执行线程
* 一种则是实现Runnable接口,然后通过Thread的构造器将实现Runnable接口的类对象赋值到成员变量target中,随后调用`Thread.start()`执行`Thread.run()`执行`MyRunnable.run`从而执行线程

Java不支持多重继承而可以支持多重实现,所以第二种方法会比较解耦。

### 2.线程中断

```java
public void Thread.interrupt()//中断线程

public boolean Thread.isInterrupted()//判断是否被中断
    
public static boolean Thread.interrupted()//判断是否被中断，并清除当前中断状态 
```

**注：interrupt()方法只是将线程置中断标记位(非线程状态)，并不会真正中断线程，如果想要中断线程需在run()方法头进行状态判断从而手动中断**

注：`Thread.sleep()`方法(使线程状态进入TIMED_WAITTING状态)会由于中断而抛出异常，==此时，它会清除中断标记**（注意是中断标记而不是线程状态）**==，那么在下一次循环开始时，就无法捕获这个中断，所以在异常处理时要再次设置中断标记位

### 3.异常处理

对于使用new Thread(··)构造线程的有两种方法处理异常

* 对于受查异常,只能在`run()`内自行使用try-catch块捕获处理
* 对于非受查异常,需要为Thread构造一个UncaughtExceptionHandler以处理非受查异常

### 4.条件队列

#### Ⅰ、基本使用方法及基本原理

`object.wait()`和`object.notify()`方法必须包含在对应的synchronized语句中，两个方法调用之前都要先获得object监视器==**(同一个对象的锁)**==才能执行，**wait()方法执行后会自己释放锁，而notify()不会自己释放锁，要执行完所在`Synchronized`块之后才会释放**

当一个对象在当前线程中调用`wait()`方法后，当前线程将会进入这个==**锁住的对象(不同的锁对象有各自的等待队列)**==的等待队列。这个等待队列可能会有多个线程，而当这个对象的`notify()`方法调用，对象就会从这个等待队列中**随机选择**==(这一点和Condition实现不同)==一个线程，将其==**唤醒(⭐*注:当线程被唤醒后,它在重新请求锁时不具有任何特殊的优先级,而要与其他尝试进入临界区的线程一起正常地在锁上进行竞争,这点和Condition则是一致的*)。**==

#### Ⅱ、由基本原理引申的使用方法

##### （1）等待

###### ①条件谓词

要想正确地使用条件队列,关键是找出对象在哪个条件谓词上等待。**==条件谓词是使某个操作成为状态依赖操作的前提条件。==**如阻塞队列的`put()`,其中队列的非满就是他的条件谓词。

###### ②过早唤醒

由于其唤醒机制(不是唤醒的线程就是下一个获得锁的线程),所以有可能轮到唤醒的线程获得锁的时候条件谓词又为false了。

如生产者消费者模式中，生产者将任务放入阻塞队列后唤醒某条消费者线程，而当生产者释放锁后，另外一条消费者线程获得锁从而将这个任务消费了。此时队列为空，但被唤醒的在同步队列中的线程并不知道这一点，这条线程一旦获得锁后就会向下继续执行获取到空任务从而报错。

所以基于上面的分析，在唤醒之后仍要需要有一个检查机制判断当前状态是否符合条件谓词要求。即

```java
while(!条件谓词)
{
    object.wait();
}
//执行到这里是才会是正确的状态
```

##### （2）通知

###### ①通知时机

确保在`wait()`的条件谓词变为真时发出通知

###### ②`notify()`和`notifyAll()`

由于是每个对象锁拥有着一个条件队列而不是每个条件谓词拥有一个条件队列,所以完全有可能在一个`Synchronized`块中需要使用两个以上的条件谓词(多个条件谓词放在不同的while循环里的情况)。**所以若在这种情况下使用`notify()`将是不安全的,因为这有可能唤醒了一个等待不同条件的线程，而真正等待这个条件的线程却没有收到通知，此时则应该使用`notifyAll()`**

##### （3）`wait/notify`与`Condition`的区别

最大的区别就是，`wait/notify`可以有多个条件谓词，但是因为这些条件谓词而阻塞的线程只存放在一个条件队列上。

而`Condition`同样可以定义多个条件谓词，并且每个条件谓词都可以拥有一个属于自己的条件队列，这样就不会出现`wait/notify`那种调用一次`object.notifyAll()`就把因为各种条件谓词而阻塞的线程都全部唤醒

#### 5.等待线程结束和谦让

`thread.join()`方法让当前线程阻塞直到调用方法的线程对象执行完毕.

==注:`thread.join()`方法的本质是 调用`thread.wait()`方法,当`thread`线程执行完毕后退出前调用`thread.notifyAll()`通知所有等待线程继续执行.**所以不要随意调用Thread对象的`join()`,因为有可能会唤醒其他真正因为条件谓词而等待`thread`对象的线程**==

#### ⭐6.volatile与JMM

volatile标注的变量:每次读取数据都从主内存取而不只是从cache中读,解决数据不一致的问题

**注:线程修改变量时,先从主内存拷贝到线程内存,对线程内存的变量做修改后,将线程内存变量值赋值回主内存;但从第二次开始就不会拷贝主内存的值,而是直接对线程内存值做修改,这就引发了不一致**

#### 7.⭐守护线程（未完待续）

守护线程会执行到目标线程退出时退出.

#### 8.隐蔽的错误

Integer对象如果被当作锁,那千万不可以改变对象的值,例如如果对`Integer i=0;`使用了`i++`,那么就会新建一个Integer对象并将新值1赋值给它,对象改变,锁失效

#### 9.==synchronized==

关键字synchronized可以有多种用法

* 指定加锁对象:对给定对象加锁,在进入同步代码前要获得给定对象的锁.
* 直接作用于实例方法:相当于对==**当前实例**==加锁,进入同步代码前要获得当前实例的锁
* 直接作用于静态方法:相当于对==**当前类**==加锁,进入同步代码前要获得当前类的锁