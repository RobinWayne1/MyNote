# 第四章 锁的优化和注意事项

### 一.提高锁性能的几点建议

#### 1.减少锁持有的时间

根据实际情况减少锁的持有时间,但是也要**关注线程是否频繁的在做无谓的浪费系统资源的锁切换操作**.

#### 2.锁分段

ConcurrentHashMap是典型的锁分段优化性能的例子。对于ConcurrentHashMap类，它改变了放置桶的数组的概念，称之为**段**(默认有16个段)。==**如果需要在ConcurrentHashMap类中增加一个新的值，并不是将整个HashMap加锁，而是首先根据hashcode得到该k-v对应该被存放到哪个段中，然后对该段进行加锁，并完成put操作。**==

而这种技术的劣势则在于：如果需要获得多个锁来实现独占访问将更加困难并且开销更高，比如size()方法,要获取所有段的锁之后,获得每个段的k-v数量,然后相加获得总量返回数据.

然而ConcurrentHashMap并不是总会这样执行,它会先用无锁的方式求和,失败才会用最消耗资源的方式求和.

所以只有在获取全局信息的方法调用不频繁的时候,减小锁粒度的方法才能在真正意义上提高系统的吞吐量.

**总结:锁分段的目的是为了减少对同一对象不同状态(或者说同一数据的不同部分)访问时锁的竞争。如果要使用锁分段技术,那么在未分段前程序一定要表现出在锁上的竞争频率高于在锁保护的数据上发生竞争的频率(即分段前锁的竞争一定要比分段后的要大,锁分段才有用)。**

#### 3.用读写分离锁来替换独占锁

如果说减小锁粒度是通过分割数据结构实现的,那么读写分离锁则是对系统功能点的分割

#### 4.锁分离

对读写锁的思想进一步延伸,就是锁分离.依据应用程序的功能特点,使用类似的分离思想,也可以对独占锁进行分离.

在LinkedBlockingQueue的视线中,take()和put()分别实现了从队列中取得数据和往队列中增加数据的功能.虽然两个函数都对当前队列进行了修改操作,⭐==**但由于LinkedBlockingQueue是基于链表的,因此两个操作分别作用于队列的前端和尾端(在源码中分别使用tackLock和putLock表示),从理论上说,两者不冲突.（重点注意：ArrayBlockingQueue是没有锁分离的）**==

因此在JDK实现中,并没有采取独占锁的方式,而是用两把不同的锁分离了take()和put()方法的操作.

#### 5.扩大锁粒度或减小锁粒度



### 二.虚拟机对锁的优化

#### 1.锁偏向

锁偏向是一种针对加锁操作的优化手段.它的核心思想是:当**第一个**线程获得了锁,那么锁就进入偏向模式.如果接下来没有其他线程获取锁,当这个线程再次请求锁时,就无需再做任何同步操作,节省了大量有关锁申请的操作。而有这种机制适合在几乎没有锁竞争的场合使用.

#### 2.轻量级锁(?)

#### 3.自旋锁

当获取对象锁失败后,为避免线程真实的在操作系统层面挂起(因为也许在几个时钟周期之后就可以得到锁,如果这样,挂起线程可能是得不偿失的).因此,虚拟机会让当前线程做几个空循环,如果可以的到锁,那么就顺利进入临界区;如果还得不到锁,才会真的将线程在操作系统层面挂起。**==而这也是对象锁不公平的原因，只有轻量级锁有自旋。==**

#### 4.锁消除

虚拟机在JIT编译时,==**通过对运行上下文的扫描,取出不可能存在共享资源竞争的锁进行消除**==.例如在方法内局部创建Vector局部使用,由于是线程私有数据,不可能被其它线程访问,因此这种情况下加锁同步是没有必要的.

锁消除的技术成为逃逸分析,**==就是观察某一个变量是否会逃出某一个作用域==**,例如将局部变量Vector对象返回出去,那么就认为此变量逃出了当前函数,就不能进行锁消除

### 三.ThreadLocal

ThreadLocal的思想是:每个线程都要使用某个共享对象的功能,但是又碍于是在多线程环境下,**如果用比较低效率的方法使用这个共享对象那就是加锁,但是比如数据库连接connection,一个connection连接只能供一个线程使用的话效率太低;而同时又希望避免在每次执行时都重新分配connection对象,就可以用ThreadLocal.**

ThreadLocal相当于为每一个线程创建一个资源的副本,ThreadLocal的set()方法将以当前ThreadLocal实例为键,创建的副本为值放进**当前线程的ThreadLocalMap变量**中;或实现ThreadLocal的initialValue(),当第一次调用get()方法时会调用initialValue()方法来获取初始值

还有个垃圾回收机制,可以看书,这里不提及.

### 四.无锁

无锁的策略--CAS(比较交换),使用这种策略鉴别线程冲突.

#### 1.与众不同的并发策略:比较交换

CAS的算法过程:它包含三个参数

* V:要更新的变量
* E:修改变量时预期变量的值(预期值)
* N:新值

仅当V=E时,才将V的值设为N;如果V!=E说明有其他线程做了更新,当前线程则什么都不做.

#### 2.带有时间戳的对象引用:AtomicStampedReference

AtomicReference的缺点是:对象在修改过程中丢失了状态信息,对象之本身与状态画上了等号,即在AtomicReference拿到预期值之后,其他线程可以对对象进行多次修改,**只要在当前线程做CAS操作之前将对象修改回原状态则无法被检测出来**.

AtomicStampedReference解决了这个问题,当AtomicStampedReference对应数值被修改时,除了更新数据本身,还要更新时间戳,**在进行CAS操作时,预期值是对象的值和时间戳,保证了状态和值的一致性**。

```java
compareAndSet(V   expectedReference,
                                 V   newReference,
                                 int expectedStamp,
                                 int newStamp) 
```



### 五.活跃性问题

一个并发应用程序能及时执行的能力称之为活跃性。

活跃性危险:

* 死锁：所有线程都在循环等待其他进程手里的资源
* 活锁：指的是任务没有阻塞，但是由于某些条件的不满足使得任务一直重试且一直失败，浪费系统资源的过程
* 饥饿：由于其他任务一直占用资源，从而导致当前任务无法获得所需要的资源而一直无法运行。可以说一下读写锁。

### 六.线程上下文切换

上下文就是指通用寄存器和程序计数器,切入的方法和切出的方法可以讲一下(改变线程状态的几个方法)。

