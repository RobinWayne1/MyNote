# 零拷贝原理

零拷贝技术的产生就是为了在进行网络IO文件传输时，减少用户态内核态的上下文切换还有减少占用CPU时间的拷贝次数，零拷贝的最终目的就是将占用CPU时间的拷贝次数变成0。不过在看下文时请先注意：一切的优化都是基于用户进程不对从磁盘读出来的数据进行处理为背景的,也就是说用户进程相当于一个数据传输的中介而已。

## 一、传统文件传输

如果没有DMA基础的同学要去看看设备控制器原理。

在用户进程中，传统I/O方式涉及到两个系统调用

```c
read(file, tmp_buf, len);
write(socket, tmp_buf, len);
```

其大致流程如下:



<img src="E:\Typora\MyNote\resources\Java\IO\传统IO方式的传输过程.png" />

1. 用户进程调用`read()`方法,触发用户态→内核态的切换。
2. 内核态负责进行磁盘读取，一般采用DMA技术由设备控制器负责将磁盘中的数据直接读取到内存的内核缓冲区中（更加细分一点的名称就叫`PageCache`）
3. 在读取到内核缓冲区后,CPU负责将`内核缓冲区的数据`拷贝`到用户空间`。（这里其实就是Linux五种IO模型之一的阻塞IO）
4. 此时`read()`方法方法返回并且操作系统从内核态切换到了用户态，这个时候用户进程就会调用`write()`方法向`网卡`写入数据
5. 这个时候又会触发用户态→内核态的切换,CPU此时就会将数据从用户空间中写进内核的`sokcet缓冲区里`
6. CPU通知设备控制器进行数据写入,设备控制器进行数据DMA拷贝到网卡中,完成文件传输。

在上述流程中涉及到四次内核态用户态的上下文切换，两次占用CPU时间的拷贝。很显然，这种调用其实有很多步骤是完全不需要的，因为用户进程根本不需要对该文件进行处理或修改。

## 二、mmap(memory map)+write

`mmap()`取代了`read()`,减少了一次CPU拷贝。

而同样的，这种方式也涉及了两次系统调用：

```c
buf = mmap(file, len);
write(sockfd, buf, len);
```

大致流程：

![](E:\Typora\MyNote\resources\Java\IO\mmap IO流程.png)

1. 用户进程调用`mmap()`后,设备控制器进行DMA拷贝将数据放到`内核缓冲区`后,应用进程就会与内核共享这块`内核缓冲区`。
2. 在用户进程调用`write()`函数后,CPU就会将`共享的内核缓冲区`数据拷贝到`Socket缓冲区`
3. 然后CPU通知设备控制器,设备控制器利用DMA拷贝将数据送出

==**mmap的技术要点就是让用户共享了这一块内核缓冲区,所以减少了一次从内核空间到用户空间的CPU拷贝**==

## 三、sendfile()

### Ⅰ、 Linux 内核版本 2.1

在 Linux 内核版本 2.1 中，提供了一个专门发送文件的系统调用函数 `sendfile()`，函数形式如下：

```c
#include <sys/socket.h>
ssize_t sendfile(int out_fd, int in_fd, off_t *offset, size_t count);
```

前两个参数分别代表目标文件描述源文件描述符,目标文件描述符,第三个参数代表源端偏移量,第四个参数代表发送的数据的长度。

大致流程如下:

![](E:\Typora\MyNote\resources\Java\IO\sendfile IO流程.png)

`sendfile()`系统调用，可以直接把内核缓冲区里的数据拷贝到 socket 缓冲区里，不再拷贝到用户态，这样就只有 2 次上下文切换，和 3 次数据拷贝。也就是比`mmap()`少了两次系统调用。

### Ⅱ、Linux 内核版本 2.4

如果网卡支持 `SG-DMA`（*The Scatter-Gather Direct Memory Access*）技术（和普通的 DMA 有所不同），那么可以进一步减少通过 CPU 把内核缓冲区里的数据拷贝到 socket 缓冲区的过程。





pagecache的概念