# MappedByteBuffer

demo

## 二、基本概念

MMU：内存管理单元，也就是地址变换机构，负责管理页表以及虚拟地址到物理地址的转换。

虚拟内存：即非连续存储管理，即让程序认为其所使用的内存是连续的，而实际上在物理内存中分配成了多个物理内存碎片。

虚拟地址：虚拟地址指的就是在OS底层是非连续存储管理（虚拟内存）条件下，程序寻找内存时所使用的地址。如分页存储管理中的逻辑地址，由页号+页内偏移量表示。

> 这里仅按我当前阶段理解范围内来解释，因为我所学的OS只是和Linux内核应该有些差异。

## 三、mmap原理

<img src="E:\Typora\MyNote\resources\Java\IO\linux进程内存空间与内存映射文件.jpg" style="zoom:67%;" />

linux虚拟内存的空间分配如上图所示（留意运行时堆与共享库存储器映射区域）。

在调用mmap函数时，内核会将所要读取的文件映射到用户进程虚拟内存的**==共享库存储器映射区域==**中（英文名称`Memory mapped region for shared libraries`,**==这段虚拟内存就是专门用来与磁盘中的文件建立映射关系的，这层关系其实就是在请求页表中添加一个页表项==**）。之后在用户进程读取内存数据，查看请求页表发现无法找到页号具体对应页框时触发缺页异常，内核从而通过请求页表中记录的文件所在磁盘地址寻页或选择一页换出或分配新页（注意上面这段话的用词，去查查共享映射区域到底是干嘛的？存放掉页的页还是只做一层映射关系）

mmap机制详细解析（包括一些filechannel的源码）

重点讲进程在linux里的内存结构，以及有专门虚拟内存存放mmap的数据的这一机制，再加上个请求调页就可以了。

mmap是用请求页表的缺页中断机构来完成快速读取的，之前的误解：所谓的映射，还以为是mmu在读某内存地址的时候指定到磁盘地址中，所以我就想，那不是要将磁盘的文件所占用空间的地址都映射到内存中预先分配好内存？？？放屁！这个地址映射的表示就是在请求页表里面做的，根本不关真正存储数据的内存页的事。。。。好像也不是





