# MESI协议

在SMP架构下，每个处理器和主存之间通过一条总线相连，而每个处理器都设有一个高速缓存。高速缓存是一种存取速率远比主内存大而容量远比主内存小的存储部件。引入高速缓存之后，CPU不直接与内存打交道，而是会先操作高速缓存。

## 一、Cache结构

高速缓存是一个使用取余法确定桶位置，用开链法（闭散列法[线性探测法,二次探测法(也就是后移n^2)]）解决Hash碰撞的散列表。他以数据的主内存地址作为key，具体数据值副本为value形式存储在高速缓存中。而与普通开链散列表不同的是，Cache的存储空间很小，所以并不是所有数据都能存储到Cache中。散列表包含若干个桶，而每个桶中处理哈希碰撞的结点则称为缓存条目。

<img src="E:\Typora\MyNote\resources\Java\JCP\高速缓存结构.png" style="zoom:60%;" />

缓存条目可被进一步划分为Tag、Data Block以及Flag这三个部分。

1. DataBlock也被称为缓存行(CacheLine),它是高速缓存与主内存之间的数据交换最小单元，用于存储从内存中读取的或者准备写往内存的数据。从代码的角度来看,一个缓存行可以存储若干变量的值，**而多个变量的值则可能被存储在同一个缓存行之中**。
2. Tag包含了与缓存行中数据相应的内存地址的部分信息(内存地址的高位部分比特)。
3. ⭐Flag用于表示相应缓存行的状态信息。缓存行的容量(也被称为缓存行宽度)通常是2的倍数，其大小在16~ 256字节(Byte)之间不等。

<img src="E:\Typora\MyNote\resources\Java\JCP\缓存条目结构.png" style="zoom:90%;" />

### Ⅰ、数据插入和读取

其实数据插入和读取和Java的HashMap差不多，但是对于作为key的内存地址还需要一步解码才能真正确定该数据应存放的缓存数据位置（如缓存行不止存放一个变量造成的）。

内存地址的解码结果包括tag、index以及offset这三部分数据。

1. index相当于桶编号，它可以用来定位内存地址对应的桶; 
2. 一个桶可能包含多个缓存条目，tag 相当于缓存条目的相对编号,其作用在于用来与同一个桶中的各个缓存条目中的Tag部分进行比较，以定位一个具体的缓存条目
3. 一个缓存条目中的缓存行可以用来存储多个变量，offset 是缓存行内的位置偏移，其作用在于确定一个变量在一个缓存行中的存储起始位置。

## 二、缓存一致性协议之MESI

多个线程并发访问同一个共享变量的时候,这些线程的执行处理器上的高速缓存各自都会保留一份该共享变量的副本,这就带来一个新问题一一个处理器对其副本数据进行更新之后，其他处理器如何“察觉"到该更新并做出适当反应，以确保这些处理器后续读取该共享变量时能够读取到这个更新。这就是缓存一致性问题，其实质就是如何防止读脏数据和丢失更新的问题。为了解决这个问题，处理器之间需要一种通信机制一缓存一致性协议( Cache Coherence Protocol )。

### Ⅰ、缓存行的状态

在上面介绍缓存条目的结构时并没有细讲其状态flag，原因就是这个标志位是MESI协议的重要体现之处，状态flag将用于协调各个处理器的写和读操作。

1. Invalid(无效的,记为I)。**该状态表示相应缓存行中不存在任何内存地址对应的有效副本数据。**该状态是缓存条目的初始状态
2. Shared(共享的，记为S)。该状态表示相应缓存行包含相应内存地址所对应的副本数据。**并且，其他处理器上的高速缓存中也可能包含相同内存地址对应的副本数据。**因此，一个缓存条目的状态如果为Shared,并且其他处理器上也存在Tag值与该缓存条目的Tag值相同的缓存条目,那么这些缓存条目的状态也为Shared。处于该状态的缓存条目，其缓存行中包含的数据与主内存中包含的数据一-致。
3. Exclusive(独占的，记为E)。该状态表示相应缓存行包含相应内存地址所对应的副本数据。**并且，该缓存行以独占的方式保留了相应内存地址的副本数据，即其他所有处理器上的高速缓存当前都不保留该数据的有效副本。**处于该状态的缓存条目，其缓存行中包含的数据与主内存中包含的数据一致。
4. Modified (更改过的，记为M)。**该状态表示相应缓存行包含对相应内存地址所做的更新结果数据，而这个数据是写在了缓存中而还没有写回内存。**由于MESI协议中的任意一个时刻只能够有一个处理器对同一内存地址对应的数据进行更新，因此在多个处理器上的高速缓存中Tag值相同的缓存条目中，**任意一个时刻只能够有一个缓存条目处于该状态。**处于该状态的缓存条目，其缓存行中包含的数据与主内存中包含的数据不一致。

### Ⅱ、MESI消息

为了协调各个处理器的工作，MESI协议还定义了一组消息供各个处理器通信，该消息的机制有点类似于HTTP，有请求和应答的过程。

<img src="E:\Typora\MyNote\resources\Java\JCP\MESI消息①.png" style="zoom:60%;" />

<img src="E:\Typora\MyNote\resources\Java\JCP\MESI消息②.png" style="zoom:60%;" />

### Ⅲ、写缓冲器（存储转发）和无效化队列

本来这两个组件并不是必须的，但是通过上面的MESI消息可以看到，消息的传播需要时间，如一个写操作需要向所有处理器发送消息I，而该处理器在等待其他处理器响应消息时是停止运行的，所以这个等待的时间将成为MESI协议的性能瓶颈。所以为了优化消息的传播则必须有这两个组件，然而这两个组件却是导致内存可见性和有序性问题的罪魁卧首。

写缓冲器(StoreBuffer,也被称为WriteBuffer)是处理器内部的一个容量比高速缓存还小的私有高速存储部件，每个处理器都有其写缓冲器，写缓冲器内部可包含若干条目(Entry)。**一个处理器无法读取另外一个处理器上的写缓冲器中的内容。（产生问题的地方）**。在进行数据写时CPU不再等待消息响应，而是直接将数据先存放到写缓冲器中就返回。到消息响应全部到达时再将写缓冲器的数据真正写到高速缓冲中。而在这段时间间隔内，若CPU要读取修改了的那条数据（即目前在写缓冲器中的数据），此时就会直接将写缓冲器的数据返回而不会查看高速缓冲或使用消息，这就叫存储转发。

无效化队列( Invalidate Queue)同样是处理器内部的一个私有高速存储部件，每个处理器都有其无效化队列。引入无效化队列之后，处理器在接收到Invalidate 消息之后并不删除消息中指定地址对应的副本数据，而是将消息存入无效化队列之后就回复`InvalidateAcknowledge`消息，从而减少了写操作执行处理器所需的等待时间。

### Ⅳ、具体过程

下面将以Processor1和Processor2加上写缓冲器和无效化队列部件来讨论CPU的读和写操作。

#### ①、共享数据读操作

Processor1想要读取共享数据时，先检查写缓冲器中有没有该数据，若有则直接存储转发；若没有就继续寻找高速缓存。同样的，在高速缓存中先通过内存地址查找是否有该数据，若有该缓存条目且其状态位为E/M/S，则可以直接返回高速缓存的数据。而若缓存条目状态位为I，此时就需要向总线发出`read`消息。

Processor2在嗅探到Processor1的`read`消息后,检查自己的高速缓冲中该缓存条目的状态,若该缓存条目状态为E/S,则直接将该条目的数据整行放入`read response`消息中返回给Processor1,并将缓存条目状态更新为S。**而如果缓存条目状态为M则稍微有些不同，在将该条目数据放入消息之前Processor2会使用`writeback`消息将该缓存行数据写回主存**。若Processor2的目标缓存条目状态为I，则Processor1最终接收到的`read response`消息将来自主存。由于读主存消耗的时间比较长，所以这种情况应该避免发生。

Processor1在收到`read response`消息的数据后，将数据写入高速缓存并将该缓存条目的状态为改为S。

<img src="E:\Typora\MyNote\resources\Java\JCP\共享数据读操作.png" style="zoom:60%;" />

#### ②、共享数据写操作

Processor1想要更新共享数据，他就会先检查高速缓存中该缓存条目的状态，如果状态是E/M这种独占状态的话，此时就可以直接修改该缓存条目并将状态位置为M。

若Processor1缓存条目状态是S，此时就将所要更新的数据写入写缓冲器中并往总线发送`Invalidate`消息,之后CPU继续做其他事。Processor2收到消息后，直接将该条消息放入无效化队列后直接返回`Invalidate Acknowledge`消息。Processor1在收到响应后就将写缓冲器的缓存条目写入高速缓存，并将标志为置M,至此写操作才完成。

与上面类似，若Processor1缓存条目状态是I，此时就将所要更新的数据写入写缓冲器中并往总线发送`Read Invalidate`消息,之后CPU可以继续做其他事。Processor2收到消息后，直接将该条消息放入无效化队列后直接返回`read response`(如果Processor2该缓存条目是M/E/S才回复该消息)和`Invalidate Acknowledge`消息。Processor1在收到响应后就将写缓冲器的缓存条目写入高速缓存，并将标志为置M,至此写操作才完成。

<img src="E:\Typora\MyNote\resources\Java\JCP\共享数据写操作.png" style="zoom:60%;" />

### Ⅴ、写缓冲器（存储转发）和无效化队列的内存可见性和重排序

要知道，无论是写缓冲器还是无效化队列，它们两者和高速缓存都是没有保证信息一致的，这就是问题的关键点。如一个处理器更新变量后，此时该变量值在写缓冲器中，而此时其他处理器过来取变量时就会取到了该处理器高速缓存中的过时数据，这就造成了内存可见性问题。