# 第六章 复制

### 一.配置

#### 1.建立复制

* slaveof配置都是在从节点发起的。
* info replication可以查看复制相关状态。

#### 2.断开复制

* 从节点断开复制后并不会抛弃原有数据,只是无法获取主节点上的数据变化。
* **切换主节点会删除从节点当前所有数据,并对新主节点进行赋值操作。**

#### 3.只读

默认情况下从节点为只读模式(可配置),**由于复制只能从主节点到从节点,对于从节点的任何修改主节点都无法感知**

,==修改从节点会造成主从数据不一致==。

#### ==4.传输延迟==

repl-disable-tcp-nodelay参数用于控制是否关闭TCP-NODELAY,当关闭时,主节点产生的命令数据无论大小都会及时发送给从节点,主从延迟变小但增加网络带宽消耗；当开启时,主节点会合并较小的TCP数据包从而节省带宽。

### 二.原理

#### ==1.复制过程==

从节点执行slaveof命令:

(1)从节点保存主节点信息并返回,此时复制流程并没有开始

(2)从节点内部通过每秒运行的定时任务维护复制相关逻辑,当定时任务发现存在新的主节点后,则会尝试与该节点建立网络连接.如果从节点无法建立连接,定时任务会无限重试知道连接成功或者执行slaveof no one取消复制

(3)发送ping命令,目的是检测主从之间网络socket是否可用和检测主节点当前是否可接受处理命令

(4)权限验证

==(5)同步数据集.主从复制连接正常通信后,主节点把持有的数据全部发送给从节点**(进行全量复制)**==

(6)命令持续复制

#### ==2.数据同步==

Redis使用psync命令完成主从数据同步,同步过程分为全量复制和部分复制

psync命令要以下组件支持:**主从节点各自的复制偏移量**,**主节点复制积压缓冲区**,**主节点运行id**

* #####  复制偏移量

  ​	参与复制的主从节点都会维护自身复制偏移量.主节点在处理完写入命令后会把命令的字节长度做累加记录进复制偏移量中,从节点在接收到主节点发送的命令后也会累加记录自身的偏移量.根据master_repl_offset和

  slave_offset的字节量差值可看出主从节点的复制延迟字节.

* ##### ==复制积压缓冲区==

  ​	复制积压缓冲区时保存在主节点上的一个固定长度的队列,默认大小为1mb.当主节点有连接的从节点时被创建,**这时主节点响应写命令时,不但会把命令发送给从节点还会写入复制积压缓冲区,用于保存最近已复制数据的功能,用于部分复制.**

* ##### 主节点运行id

  ​	Redis节点启动后都会动态分配一个40位的十六进制字符串作为运行id,Redis关闭再启动后,运行id会随之改变,运行id变化之后从节点将做全量复制.当调优一些内存相关配置时可以使用debug reload命令重新加载RDB而保持运行id不变,从而避免不必要的全量复制.

* ##### psync命令

  格式:psync {runId} {offset}

  从节点发送此命令给主节点,主节点根据psync参数和自身数据情况决定响应结果时全量复制还是部分复制

#### 3.⭐全量复制==（复制强调数据一致性，所以需要像`AOF重写缓冲区`那样的 `复制积压缓冲区`保存fork后主redis进程执行的命令）==

* ##### 流程说明

  1. **发送psync命令进行同步,由于第一次复制,没有runId和偏移量,所以发送" psync ? -1 "**

  2. **主节点回复+FULLRESYNC**

  3. **从节点接收到主节点的响应.保存运行ID和偏移量offset**

  ==重点：==

  4. ***主节点执行bgsave保存RDB文件到本地***

  5. ***主节点发送RDB文件给从节点,从节点保存在本地并直接作为数据文件***

  6. ***由于从节点开始接收RDB快照到接收完成期间,主节点仍然相应命令,主节点把这期间的写命令数据保存在==复制客户端缓冲区==内,当从节点加载完RDB文件,主节点再把缓冲区内的数据发送给从节点以保持数据一致*性** 

  

  7. **从节点清空旧数据**
  
  8. **从节点开始加载RDB文件**
  
  9. **如果从节点开启了AOF功能,从节点会立即做AOF重写以保证全量复制后AOF持久化文件可用**

#### 4.⭐部分复制

* ##### 流程说明

  1. **当主从节点之间网络出现中断**

  2. **中断期间主节点依然响应命令,但因复制连接中断命令无法发送给从节点,==不过主节点内部存在的复制积压缓冲区依然可以保存最近一段时间的写命令数据==**

  3. **主从节点网络恢复,由于从节点之前保存了自身已复制的偏移量和主节点的运行ID,因此把他们当作psync参数发送给主节点要求进行部分复制**

  4. **主节点收到psync命令后先核对参数runId是否一致,之后根据参数offset在自身复制积压缓冲区查找,如果偏移量之后的数据存在缓冲区中,则对从节点发送+COUNTINUE响应**

  5. **主节点发送数据**

#### 5.心跳

* 主节点每隔10秒对从节点发送ping命令判断从节点的存活性和连接状态
* 从节点在主线程**每隔1秒发送replconf ack{offset}命令,给主节点上报自身当前的复制偏移量**,作用如下:
  * 实时检测主从节点网络状态
  * ==上报自身复制偏移量,检查复制数据是否丢失,如果从节点数据丢失,再从主节点的复制缓冲区中进行部分复制拉取数据==
  * 主节点根据replconf命令判断从节点延迟时间并记录在info replication的lag中

#### 6.异步复制

​	写命令的发送过程是异步完成,**也就是主节点自身处理完写命令后直接返回给客户端,并不等待从节点复制完成,这就造成了从节点的数据相对主节点存在延迟.**

### 三、开发与运维中的问题

#### 1.读写分离

对于读占比较高的场景，可以通过把一部分读流量分摊到从节点来减轻主节点压力，即只对主节点执行写操作，而只对从结点执行读操作，**这个逻辑要通过客户端来实现。**

##### ①问题

###### Ⅰ、读到过期数据

过期键的删除策略有两种：惰性删除和定时删除。

然而，从节点自身永远不会主动删除超时数据，主节点又一般不执行读操作，则导致惰性删除不在主从复制结构中起作用，所以只能靠主结点的定时删除策略进行键的删除。如果定时删除任务跟不上键的过期速度，就会在从节点读取到过期数据。

**在Redis3.2版本中解决了这个问题，从节点返回数据之前会检查键的过期时间来决定是否返回数据。**