# 第十一章 事件

### 一.文件事件

Redis服务器通过socket与客户端进行连接,而文件事件就是服务器对套接字操作的抽象。服务器与客户端的的通信会产生相应的文件事件，而服务器则通过监听并处理这些事件来完成一系列网络通信操作。

* 文件事件处理器使用I/O多路复用程序来同时监听多个socket,**并根据socket目前执行的任务来为socket关联不同的事件处理器**
* 当被监听的socket准备好执行连接应答,读取,写入,关闭等操作时,与操作相对应的文件事件就会产生,这时文件事件处理器就会调用套接字之前关联好的事件处理器来处理这些事件                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 

#### 1.文件事件处理器的构成（即Reactor模型）

![img](https://img-blog.csdn.net/20180409084852324?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTQ1OTA3NTc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

文件事件处理器由套接字,I/O多路复用程序,文件事件分派器和事件处理器构成.

* 当被监听的socket准备好执行连接应答,读取,写入,关闭等操作时,就会产生一个文件事件
* I/O多路复用程序负责监听多个套接字,并向文件事件分派器传送那些产生了事件的套接字**(放入队列里进行传送)**
* 文件事件分派器接收I/O多路复用程序传来的套接字,并**根据套接字产生的事件的类型,调用相应的事件处理器**
* 服务器会为执行不同任务的套接字关联不同的事件处理器,这些处理器时一个个函数,他们定义了某个事件发生时,服务器应该执行的动作

#### 2.事件的类型

* 当套接字变得可读时(客户端对套接字执行write操作)或者有新可应答套接字出现(建立连接请求),套接字产生AE_READABLE事件
* 当套接字变得可写时(客户端对套接字执行read操作)套接字产生AE_WRITABLE事件

如果一个套接字同时产生这两种事件,那么文件事件分派器会优先处理readable事件,等readable事件处理完之后才处理writable事件

#### 3.文件事件处理器(完美的Reactor网络模型)

最常用的三种处理器:连接应答处理器,命令请求处理器,命令回复处理器

* 为了对连接服务器的各个客户端进行应答,服务器要为 监听套接字 关联连接应答处理器.当Redis服务器进行初始化的时候,程序会将这个连接应答处理器和服务器监听套接字的AE_READABLE事件关联起来

* 为了接收客户端传来的命令请求,服务器要为客户端套接字关联命令请求处理器.在客户端连接服务器的整个过程中,服务器都会一直为客户端套接字的AE_READABLE事件关联命令请求处理器

* 为了向客户端返回命令的之形结构,服务器要为客户端套接字关联命令请求处理器。当命令回复发送完毕之后，服务器就会解除命令回复处理器与客户端套接字的AE_WRITABLE事件的关联

  ![](E:\Typora\resources\redis\10118224-70f62b9d21c8d52e.png)

具体事例看书本p155

### 二.时间事件

时间事件分为两类：定时事件和周期性事件,这取决于时间事件处理器的返回值

![](E:\Typora\resources\redis\0bll3l8nmx.jpeg)

一个时间事件由以下三个属性组成：

* id
* when(毫秒精度的UNIX时间戳,记录时间事件的到达时间)
* timeProc(时间事件处理器,一个函数.当时间事件到达时,服务器就会调用相应的处理器来处理事件)

服务器将所有时间事件都放在一个无序(指不按时间大小排序)链表中,每当时间事件执行器运行时,他就遍历整个链表,查找所有已到达的时间事件==(时间事件的when属性记录的UNIX时间戳等于或小于当前时间的UNIX时间戳)==,并调用相应的事件处理器

**注:目前版本中,正常模式下的Redis服务器只是用ServerCron一个时间事件,服务器几乎是将无序链表退化成一个指针来使用,所以使用无序链表保存时间事件不影响时间执行性能**

### ==三.事件的调度与执行==

由于服务器同时存在文件事件和时间事件两种事件类型,所以服务器必须对这两种事件进行调度,决定何时应该处理文件事件,合适又应该处理时间事件,以及花多少时间处理等等

```c
def aeProcessEvents():

# 获取到达时间离当前事件最接近的时间事件
time_event=aeSearchNearestTimer()
    
#计算最接近的时间事件距离到达还有多少毫秒
remaind_ms=time_event.when - unix_ts_now()
    
# 如果事件已到达,那么remaind_ms的值可能为负数,将他设定为0
if remaind_ms < 0:
	remaind_ms = 0
        
#根据remaind_ms的值创建timeval结构
timeval = create_timeval_with_ms(remaind_ms)
      
# 阻塞并等待文件事件产生,最大阻塞时间由传入的timeval结构决定
# 如果remaind_ms的值为0,那么aeApiPoll调用后马上返回,不阻塞
aeApiPoll(timeval)
        
# 处理所有已产生的文件事件
processFileEvents()  
        
# 处理所有已到达的时间事件        
processTimeEvents()        
```

将aeProcessEvents函数置于一个循环里面,加上初始化和清理函数,这就构成了Redis服务器的主函数:

```c
def main():
	# 初始化服务器
	init_server()
    
    # 一直处理事件,直到服务器关闭为止
    while server_is_not_shutdown():
		aeProcessEvents()
    
    # 服务器关闭,执行清理操作
    clean_server()
```

首先来解释ae.c/aeApiPoll,此函数接受一个timeval结构为参数,并在指定的时间内,**阻塞并等待**所有被aeCreateFileEvent函数设置为监听状态的**套接字** **产生文件事件**,==当有至少一个事件产生,或者等待超时后,函数返回==

以下是**事件的调度和执行规则**：

1、`aeApiPoll`（等待文件事件产生）函数的==最大阻塞时间**由到达时间最接近当前时间的时间事件决定**，这个方法既可以**避免服务器对时间事件进行频繁的轮询（忙等待）**==，也可以保证`aeApiPoll`函数不会阻塞过程时间。

2、因为文件事件是随机出现的，如果等待并处理完一次文件事件之后，**仍未有任何时间事件到达，那么服务器将再次等待并处理文件事件**。随着文件事件的不断执行，==**时间会逐渐向时间事件设置的到达时间逼近，并最终来到到达时间**==，这是服务器就可以开始处理到达的时间事件了。

3、对文件事件和时间事件的处理都是同步、有序、原子的执行的，服务器不会中途中断事件处理，也不会对事件进行抢占，因此，不管是文件事件的处理器，还是时间事件的处理器，它们都会尽可能**减少程序的阻塞时间**，并在有需要的时候主动让出执行权，从而降低造成事件饥饿的可能性。
 例如，在命令回复处理器将一个命令回复写入到客户端socket时，如果写入字节数超过了一个预设常量的话，命令回复处理器会主动用break跳出写入循环，将余下的数据流到下次再写；另外，时间事件也会将非常耗时的持久化操作放到子进程中执行。

4、因为时间事件在文件事件执行之后执行，**==并不会对文件事件进行抢占==，所以通常时间事件的实际处理时间，会比所设定的时间稍晚一些。**

![](E:\Typora\resources\redis\10118224-0e8391f35448bb55.png)

