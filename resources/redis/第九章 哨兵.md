# 第九章 哨兵

**背景:Redis主从复制模式下,一旦主节点由于故障不能提供服务,需要人工将从节点晋升为主节点同时还要通知应用放更新主节点地址**

### 一、哨兵架构

<img src="E:\Typora\resources\redis\sentinel架构.png" style="zoom:50%;" />

* ==Redis Sentinel实际上是在主从复制结构中再添加进了几个sentinel结点，**这些sentinel结点不作数据存储，它们负责检测主节点是否下线且维护主从复制的拓扑结构，从而动态的选择从节点作为新的主节点以达到故障转移。**==

* Redis Sentinel能自动完成故障发现和故障转移,并通知应用方从而实现高可用

==⭐故障转移流程**（此这个流程为记忆框架）** **（注：sentinel结点只会对主节点进行故障转移，从节点不会故障转移）**:==

(1)主节点出现故障,此时两个从节点与主节点失去连接,主从复制失败

(2)每个sentinel节点通过1s定时任务心跳检测发现节点不可达

(3)此时经历==**主观下线和客观下线**==过程,通过投票选举出某个sentinel节点作为领导者结点负责故障转移

(4)领导者节点选出其中一个从节点==（注意看选择方法）==将其升级为主节点,然后进行对配置文件内容修改和复制工作

### 二.配置优化

最主要的两个配置:

(1)sentinel monitor <master-name> <ip> <port> <qurom>

<master-name>:主节点别名

<qurom>:用于故障发现和判定:例如将qurom配置为2

* 代表至少有2个sentinel节点认为主节点不可达,这个不可达的判定才客观

* 至少要有max(quorum,num(sentinels)/2+1)个sentinel节点参与选举才能选出领导者sentinel,从而完成故障转译

当所有节点都启动后,配置文件的内容会发生变化,体现在三方面:
* sentnel节点自动发现了从节点,其余sentinel节点,通过后面会讲的10s定时任务
* 去掉了默认配置,如parallel-syncs
* 添加了配置纪元相关参数

(2)sentinel parallel-syncs <master-name> <nums> 
此配置用来限制在一次故障转移之后,每次向新的主节点发起复制操作的从节点个数

### 三.客户端连接

主节点挂了,redis sentinel完成故障转移,客户端要能获取这个变化sentinel才能真正发挥作用

而在`Java Sentinel客户端`**(通过实例化`JedisSentinelPool`从而获取`Jedis`连接,`JedisSentinelPool`会自行管理主节点的更换)**中,将主节点ip的变化的结果发给客户端的流程如下:

(1)为每一个Sentinel节点单独启动一个线程,利用Redis发布订阅功能,为每个线程订阅Sentinel节点上切换master的相关频道+switch-master

(2)sentinel在结束对主节点故障转移后会发布切换主节点的消息,客户端则会得到主节点的信息

### ==四.实现原理==

#### 1.三个定时监控任务

(1)每隔10秒,每个sentinel节点会向主节点和从节点发送info命令获取最新的拓扑结构,作用:
* 不需要显示配置从节点的原因
* 当有新从节点加入时可以立即感应出来
* 节点不可达或者故障转移后可以通过info命令实时更新节点拓扑信息

(2)每隔2秒,每隔sentinel节点会向redis数据节点的_sentinel_:hello频道上发布该sentinel节点对于主节点的判断以及当前sentinel节点的信息,同时每隔sentinel节点也会订阅该频道,作用:
* 通过频道发现新的sentinel节点
* sentinel节点之间交换主节点的状态,作为后面客观下线以及领导者选举的依据

(3)每隔1秒,每隔sentinel节点会向主节点,从节点,其余sentinel节点发送一条ping命令做一次心跳检测,来确认这些节点当前是否可达

#### ==2.主观下线和客观下线==

(1)主观下线

每个sentinel节点在做1s心跳检测时,当这些节点超过down-after-millseconds没有进行有效回复,sentinel节点就会对该节点做失败判定,这个行为叫主观下线,主观下线是一家之言,存在误判可能

(2)当sentinel主观下线的节点是主节点时,该sentinel节点会通过`sentinel is-master-down-by-addr`命令向其他sentinel节点询问对主节点的判断,**当超过quorum个数sentinel节点认为主节点确实有问题**,该sentinel节点会做出客观下线的决定**==⭐⭐⭐(注意:从节点,sentinel节点在主观下线后没有后续的故障转移操作)==**

#### 3.领导者选举

redis使用Raft算法实现领导者选举:

1. 每个在线sentinel节点都有资格成为领导者,当他确认主节点客观下线的时候,会向其他sentinel节点发送`sentinel is-master-down-by-addr`命令

2. 收到命令的sentinel节点如果没有同意过其他sentinel节点的`sentinel is-master-down-by-addr`命令,则同意该请求,否则拒绝

3. 如果该sentinel节点发现自己的票数大于等于max(quorum,num(sentinels)/2+1),则它成为领导者

4. 如果此过程没有选举出领导者,将进行下一次选举

#### 4.故障转移

1. **⭐在从节点选举一个节点作为新的主节点,方法如下**

   * 过滤:主观下线,断线,5s内没有回复sentinel心跳检测响应**(与领导者节点之间的网络状况最好的从节点)**
   * 选择slave-priority(从节点优先级)最高的从节点列表,如果不存在则继续。**（根据配置信息中的从节点优先级选择）**
   * 选择复制偏移量最大的从节点**(复制的最完整)**,不存在则继续
   * 选择**runid最小**的从节点
2. sentinel领导者对选出来的从节点执行slave no one命令

3. sentinel领导者向剩余的从节点发送命令使他们成为新主节点的从节点

4. **sentinel节点集合会将原来的主节点更新为从节点**,并对其保持关注,当其恢复后命令他取复制新的主节点

### ==⭐五.高可用读写分离==

**(1)从节点的作用**

在redis sentinel模式下,如果将从节点作为客户端的读节点,那么如果从节点出现故障,客户端就会与其失联,==所以很多时候**redis sentinel中的**从节点仅仅作为主节点的热备,不让他参与读操作==

(2)redis sentinel读写分离设计思路

但既然要在redis sentinel下使用读写分离,那么就要使用另外的方法.要能够实时掌握所有从节点的状态,把所有从节点看作一个资源池,**==客户端针对资源池连接,无论是上线还是下线从节点,客户端都能及时感知到(将其从资源池添加或删除),高可用的目标就达到了==**

