# 第五章 持久化

### 一、RDB(强调某个时间点)

RDB持久化是把当前进程数据生成快照保存到硬盘的过程,RDB是一个**紧凑压缩的二进制文件**，代表redis在某个时间点上的数据快照，

#### Ⅰ、触发方式

* 手动触发

  * `bgsave`命令使Redis进程立刻执行fork操作创建子进程,RDB持久化过程由子进程负责,完成后自动结束

* 自动触发

  * **使用`save m n`配置表示m秒内数据集存在n次修改自动触发bgsave。**周期性操作函数`serverCron()`默认每隔100ms执行一次,它的其中一项工作就是检查save选项所设置的条件是否满足,满足执行bgsave命令

  * 从节点执行全量复制操作,主节点自动执行bgsave生成RDB文件发送给从节点

  * 执行`debug reload`重新加载Redis

  * 默认情况下没有开启AOF功能执行`shutdown`命令


#### ==Ⅱ、⭐流程说明==

1. **执行bgsave命令,Redis父进程判断当前是否存在正在执行的子进程(,如RDB/AOF子进程因为正在执行所以无需再次执行),存在则直接返回。**

2. **父进程==执行fork操作创建子进程==,fork操作父进程会阻塞,`info stats`的latest_fork_usec可以获取最近一个fork耗时。==(由于RDB强调的是某个时间点的内存快照,所以对RDB持久化对fork之后的命令不感兴趣,但AOF就不一样了)==**

3. **fork完成,bgsave命令不再阻塞父进程,可以继续响应其他命令。**

4. **子进程创建RDB文件,根据父进程内存生成临时快照文件,完成后对原有文件进行原子替换。**

5. **进程发送信号给父进程表示完成,父进程更新统计信息,具体见`info Persistence`。**

#### Ⅲ、RDB文件的处理

保存:RDB保存在**dir**配置目录下,文件名通过dbfilename配置制指定。

压缩:Redis默认采用LZF算法对生成的RDB文件做压缩处理,压缩后的文件远远小于内存大小。

#### Ⅳ、==优缺点==

* 优点:
  * Redis加载RDB恢复数据远远快于AOF方式。
  * RDB文件是一个紧凑压缩的二进制文件,生成的文件较小。
* 缺点:
  * 无法做到实时/秒级持久化,因为fork操作创建子进程属于重量级操作,频繁执行成本过高。
  * 老版本不兼容新版本RDB格式。

#### Ⅴ、⭐fork进程的原理

fork创建的子进程不需要拷贝父进程的物理内存空间，而是将父进程的页表拷贝一份到子进程中，所以才能达到快照这个特点。如果没有写操作，则子进程不构造新的地址空间。

#### Ⅵ、RDB对过期键的处理
##### 1、生成RDB文件

执行bgsave时,程序会对数据库中的键进行检查,已过期的键不会被保存到新创建的RDB文件中

##### 2、载入RDB文件

* 若服务器为主服务器,那么在载入RDB文件时,程序会对文件中保存的键进行检查,未过期的键会被载入到数据库中,而过期键则会被忽略，
* 若服务器为从服务器,那么在载入RDB文件时,文件中保存的键无论过期都会被载入到数据库中，

### 二、AOF(强调实时性)

AOF(append only file)持久化:以独立日志的方式**记录每次写命令(准确来说是文本协议格式)**,重启时再重新执行AOF文件中的命令达到恢复数据的目的。

#### ==Ⅰ、⭐工作流程==

1. **所有的写入命令会追加到==aof_buf(缓冲区)==中。**

2. **AOF缓冲区根据对应的`appendfsync`策略向硬盘做同步操作==（并没有`fork`子进程）==。**

3. **随着AOF文件越来越大,需要定期对AOF文件进行==重写==以达到压缩的目的。**

4. **当Redis重启时可以加载AOF文件进行数据恢复。**

#### Ⅱ、命令写入

AOF命令写入的内容是文本协议格式,从而避免二次开销。

#### Ⅲ、==⭐文件同步==

Redis提供三种AOF缓冲区同步文件策略,由参数`appendfsync`控制。

| `appendfsync` | 说明                                                         |
| ------------- | ------------------------------------------------------------ |
| always        | 命令写入AOF缓冲区后,调用系统fsync操作同步到AOF文件,fsync完成后写线程返回。所以这对写线程来说是一个阻塞操作。该配置将导致每次写入都同步AOF文件,使得效率极低，与高性能Redis背道而驰。 |
| everysec      | 命令写入AOF缓冲区后调用系统write操作,==write完成后写线程返回。==fsync同步文件操作==由专门线程==每秒钟调用一次。所以这对写线程来说是一个异步操作。而对于安全性而言，最多会丢失1s的数据。 |
| no            | 命令写入AOF缓冲区后调用系统write操作,不对文件做fsync同步，同步硬盘操作由操作系统负责，通常同步周期最长30秒。 |

**write和fsync的说明：**

**write操作会触发延迟写机制。write操作在将数据写入操作系统缓冲区后直接返回，==而将系统缓冲区数据同步硬盘操作依赖于系统调度机制==，如缓冲区页空间写满或达到特定周期。**

**fsync针对单个文件操作（AOF文件），==强制将系统缓冲区数据与硬盘同步==，fsync将阻塞直到写入硬盘完成后返回。**

#### Ⅳ、==⭐重写机制==

重写AOF文件变小原因：

* 进程内已经超时的数据不再写入文件
* 重写==**使用进程内数据直接生成**==,并不需要对现有AOF文件进行读取，==**新的AOF文件只保留最终数据的写入命令**==
* 多条命令可以合并为一个，例如使用mset代替set，

两种触发方式：

* `bgrewriteaof`命令
* 参数`auto-aof-rewrite-min-size`:代表运行AOF重写时文件最小体积，参数auto-aof-rewrite-percentage：代表当前AOF文件空间（aof_current_size)和上一次重写后AOF文件空间（aof-base-size）的比值
* 则自动触发时机=当前AOF文件空间>最小体积&&(当前AOF空间-上一次重写后AOF文件空间)/上一次重写后AOF文件空间>=参数比值

==⭐流程说明==:

1. 执行AOF重写请求

2. 父进程fork出子进程

3. 主进程fork完成后继续响应命令,此后的写操作**将依然写入AOF缓冲区中并根据`appendfsync`策略同步到硬盘中旧的AOF文件里**（同时向AOF缓冲区和AOF重写缓冲区写入数据，**前者可能是为了处理在未重写完成时却要使用到AOF文件 的情况**）,保证原有AOF机制的正确性

4. 由于fork采用的是`写时复制技术`,fork出来的子进程只能共享fork时的内存快照,所以**父进程fork之后响应的命令要写入AOF重写缓冲区（不同于AOF缓冲区）以保存这部分数据**

5. 子进程根据内存快照按照命令合并规则写入到新的AOF文件

6. 文件写入完成后子进程发送信号给父进程更新系统信息

7. ==父进程把AOF重写缓冲区的数据写入到新的AOF文件==

8. 替换AOF文件

#### Ⅴ、重启加载

Redis**==⭐优先加载AOF文件（可能是因为redis致力于数据的实时准确性而不是重启的速度）==**,**==加载AOF文件时Redis创建一个不带网络连接的伪客户端来执行AOF文件保存的写命令==,此时的写命令会存放到客户端输入缓冲区中,为了防止某些命令数据过多造成客户端输入缓冲区溢出,在AOF重写时会检查带有多个元素的键并将命令分开,比如分开两个sadd命令添加集合数据**

#### Ⅵ、AOF对过期键的处理

如果数据库中的某个键已经过期,但他还没有被惰性删除或定期删除,那么AOF文件不会因为这个过期键产生任何影响，当过期键被删除之后,程序会想AOF文件追加del命令来显式的记录该键已被删除

### 三、⭐RDB与AOF的区别

* 记录的数据一致性要求不同
* 记录的数据格式不同
* 持久化过程完全不同