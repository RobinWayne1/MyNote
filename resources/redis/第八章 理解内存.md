# 第八章 理解内存

### 一.内存消耗

#### 1.内存使用统计

info memory命令可以获取三个内存最重要的指标used_memory,used_memory_rss和mem_fragmentation_ratio

* used_memory:Redis分配器分配的内存总量,也就是内部存储的所有数据内存占用量,其中这个指标没有把内存碎片浪费掉的内存统计进去
* used_memory_rss:从操作系统的角度显示Redis进程占用的物理内存总量
* mem_fragmentation_ratio内存碎片率

当ratio>1,说明used_memory_rss-used_memory的多出的内存被内存碎片所消耗

当ratio<1,操作系统把Redis内存交换到硬盘导致

#### 2.内存消耗划分

Redis进程消耗主要包括:**自身内存+对象内存+缓冲内存+内存碎片**,其中自身内存消耗的非常少,主要内存消耗为其他三种

* 对象内存:存储着用户所有数据,可以简单理解为size(keys)+size(values)

* **==⭐缓冲内存:客户端缓冲,复制积压缓冲区，复制客户端缓冲区,AOF缓冲区,AOF重写缓冲区==**


#### 3.内存碎片

Redis默认的内存分配器采用jemalloc,作用比如当保存5kb对象时jemalloc可能会采用8kb内存块存储,而剩下3kb变为了内存碎片不能分配给其他对象存储

#### ==⭐⭐⭐4.子进程内存消耗==

==**⭐⭐⭐写时复制技术**:在父进程没有更新写操作时,父子进程会共享相同的物理内存页,但父进程处理些请求时(写命令)则会把**要修改的页**复制一份,使父子进程拥有各自的副本,注意子进程依然读取fork时整个父进程的内存快照==,所以Redis产生的子进程并不需要消耗1倍的父进程内存,实际消耗根据fork期间写入命令量决定

### 二.内存管理

#### 1.设置内存上限

maxmemory参数限制最大可用内存,需要注意的是,maxmemory限制的是Redis实际使用的内存两,也就是used_memory统计项对应的内存,由于内存碎片存在,实际消耗的内存可能要比maxmemory设置的更大,需要小心这部分内存溢出

#### ==⭐⭐⭐2.内存回收策略==

内存回收机制主要体现两方面:

* 删除到达过期时间的键对象

  Redis所有的键都可以设置过期属性,维护每个键精准的过期删除机制会导致消耗大量cpu,所以Redis==采用惰性删除和定时任务删除机制实现回收==

  * **惰性删除:当客户端读取带有超时属性的键时,如果已经超过键设置的过期时间,会执行删除操作并返回空.而这种方式会导致如果过期键没有访问将一直无法及时删除,导致内存不能及时释放**

  * **定时任务删除:每隔一段时间执行一次删除操作，并通过限制删除操作执行的时长和频率(快模式和慢模式)，来减少删除操作对cpu的影响。另一方面定时删除也有效的减少了因惰性删除带来的内存浪费。**

    * 流程

      1. 定时任务遍历每个数据库随机检查20个键，当发现过期时删除对应的键
      2. 如果超过检查数25%的键过期，循环执行回收逻辑（可以理解为循环第12步）直到不足25%或运行超时为止，慢模式下超时时间为25毫秒
      3. 如果第二步超时，那么此时就以快模式运行回收过期任务，快模式超时时间为1ms且2s内只能运行1次

* ==内存使用达到`maxmemory`上限时触发内存溢出控制策略`maxmemory-policy`==(记法volatile代表过期键,allkeys代表所有键)

  * **noeviction**:默认策略,不会删除任何数据,拒绝写入并返回客户端错误信息,此时redis只响应读操作
  * **allkeys-lru**: 尝试回收最少使用的键（LRU），使得新添加的数据有空间存放。
  * **volatile-lru**: 尝试回收**最少使用的键（LRU）**，但仅限于在过期集合的键,使得新添加的数据有空间存放。
    * ==注:LRU和ttl算法还有一个可配置参数`maxmemory_samples`,这个参数用于控制LRU算法的精度。参数值越大，越接近真实LRU算法，消耗CPU越高也就是说效率越低。==
    * ==Redis的LRU和ttl实现：根据`maxmemory_samples`,随机从数据库中选择`maxmemory_samples`个`key`, 淘汰其中热度(最先要超时)最低的`key`对应的缓存数据.==
  * **allkeys-random**: 回收随机的键使得新添加的数据有空间存放。
  * **volatile-random**: 回收随机的键使得新添加的数据有空间存放，但仅限于在过期集合的键。
  * **volatile-ttl**: 回收在过期集合的键，并且优先回收**存活时间（TTL）较短（最近将要过期的键）**的键,使得新添加的数据有空间存放。
  * **volatile-lfu**：从已设置过期时间的数据集挑选使用频率最低的数据淘汰。
  * **allkeys-lfu**：从数据集中挑选使用频率最低的数据淘汰。
  
  这八种大体上可以分为4中，lru、lfu、random、ttl。

### 三.内存优化

#### 1.编码数据结构

编码的存在主要是作者想通过不同编码实现时间和空间复杂度平衡

编码类型转换在Redis写入类型时自动完成,这个转换过程不可逆,转换规则只能从小内存编码向大内存编码转换

##### (1)ziplist编码

ziplist编码可作为hash,list,zset类型的底层数据结构实现

ziplist内存结构:

| zlbyte | 记录整个压缩列表所占字节长度              |
| ------ | ----------------------------------------- |
| zltail | 距离尾节点的字节偏移量,方便尾节点弹出操作 |
| zllen  | 记录压缩链表节点数量                      |
| entry  | 记录具体节点                              |
| zlend  | 记录列表结尾,占用一字节                   |

entry结构:

| prey_entry_bytes_length | 记录前一个节点所占空间,用于快速定位上一个节点,比如从前往后偏移length个字节就可以找到前一个节点,用于双向链表实现如果前一个节点长度小于254字节则属性长度是1字节,大于等于254字节则会变成5字节,这个特点会引发==连锁更新== |
| ----------------------- | ------------------------------------------------------------ |
| encoding                | 当前节点的编码(字符串/整数)和数组的长度                      |
| contents                | 保存节点的值                                                 |

重要特点:

* 新增删除操作涉及内存重新分配或释放,加大了操作的复杂性
* 读写操作涉及复杂的指针移动,最坏复杂度为O(n的平方)
* 紧凑的结构实现多个元素连续存储，节省内存
* 适合存储小对象和长度有限的数据

==针对ziplist性能要求较高的场景,建议长度不要超过1000,每个元素大小控制在512字节内==

ziplist相比原生结构命令操作更加耗时

##### (2)intset

intset为set类型编码的一种,内部表现为存储有序且不重复的整数集

inset结构体:

| encoding | 整数表示类型,根据集合内最长整数值确定类型,包含:int-16,int-32,int-64 |
| -------- | ------------------------------------------------------------ |
| length   | 集合元素个数                                                 |
| contents | 整数数组,按从小到大排序                                      |

**intset当保存的整数超出当前类型时,将会触发自动升级操作且不回退,升级操作将会导致重新申请内存空间,把原有数据转换类型后拷贝到新数组,所以使用intset时尽量保持整数范围一致,防止触发升级操作造成内存浪费**.

##### (3)linklist

一个普通的双向链表,有一个list结构存储头节点和尾节点和长度等信息,还有一个链表节点listnode结构

##### (4)hashtable(字典)

```c
typedef struct dict {
// 类型特定函数
dictType *type;

// 私有数据
void *privdata;

// 哈希表, 每个字典都使用两个哈希表，从而实现渐进式 rehash 。
dictht ht[2];
{
    
    // 哈希表数组
    dictEntry **table;
	{
    
   	 	// 键
    	void *key;

   		 // 值
    	union {
            //指针
        	void *val;
            //整数
       		uint64_t u64;
        	int64_t s64;
    	} v;

    	// 指向下个哈希表节点，形成链表(将多个哈希值相同的键值对连接在一起来解决键冲突问题)
    	struct dictEntry *next;

	}
    // 哈希表大小
    unsigned long size;
    
    // 哈希表大小掩码，用于和用哈希函数(key)计算出来的哈希值做"与"操作计算出哈希表数组的索引值
    // 总是等于 size - 1
    unsigned long sizemask;

    // 该哈希表已有节点的数量
    unsigned long used;

}
// rehash 索引
// 当 rehash 不在进行时，值为 -1
int rehashidx; /* rehashing not in progress if rehashidx == -1 */

// 目前正在运行的安全迭代器的数量
int iterators; /* number of iterators currently running */
} dict;
```

###### ①rehash

随着操作不断执行,哈希表保存的键值对会逐渐地增多或者减少,为了让哈希表负载因子(ht[0].used/ht[0].size)维持合理的范围,当哈希表保存的键值对数量太多或者太少时,程序需要对哈希表的大小进行相应的扩展或者收缩

rehash步骤:

(1)为字典的ht[1]哈希表分配空间,这个哈希表的空间大小取决于要执行的操作,以及ht[0]当前包含的键值对数量

(2)将保存在ht[0]中的所有键值对rehash到ht[1]上:rehash指的是重新计算键的哈希值和索引值,然后将键值对放置到ht[1]哈希表的指定位置上

(3)释放ht[0],将ht[1]设置为ht[0],并在ht[1]创建一个空白哈希表

**注意:在在子进程存在期间,服务器会提高执行扩展操作所需的负载因子避免rehash操作以节约内存**

###### ②渐进式rehash

由于rehash巨大的计算量可能会造成系统宕机,所以redis采用渐进式rehash

步骤:

(1)为ht[1]分配空间

(2)将字典内的索引计数器变量rehashidx置0,表示rehash正式开始

(3**)在rehash运行期间,每次对字典执行crud操作时,程序除了执行制定操作还会顺带将ht[0]哈希表在rehashidx索引上的所有键值对rehash到ht[1],这一步完成之后,rehashidx属性的值增1**

(4)随着字典操作不断执行,ht[0]所有键值对都会被rehash到ht[1],此时程序将rehashidx置-1表示工作完成

**注意:在渐进式rehash期间,crud操作会在两个哈希表里面进行**

##### (5)skiplist(跳跃表)

具体实现看p39

```c
typedef struct zskiplist {

    // 表头节点和表尾节点
    struct zskiplistNode *header, *tail;
     {

    // 成员对象
    robj *obj;

    // 分值
    double score;

    // 后退指针
    struct zskiplistNode *backward;

    // 层
    struct zskiplistLevel {

        // 前进指针,指向下一个跳跃表节点
        struct zskiplistNode *forward;

        // 跨度
        unsigned int span;

    } level[];//数组,其中相同节点不同层的obj相同

}

    // 表中节点的数量
    unsigned long length;

    // 表中层数最大的节点的层数
    int level;

} zskiplist;
```

每次创建一个新跳跃表节点,程序根据幂次定律随机生成一个介于1和32之间的值作为level数组的大小作为层的高度(插入节点后原链表数量增多,要考虑是否为这个节点增加多层索引)

##### (6)embstr和raw

当字符串对象保存短字符串时,embstr编码则通过调用一次内存分配函数来分配一块连续的空间给redisobject和sds,而raw编码则会各分配一次内存空间

#### 2.字符串对象

Redis自己定义了SDS结构:**len(已用字节长度),free(未用字节长度),buf(字节数组)**,有如下特点:

- 内部实现空间预分配机制,降低内存再分配次数
- 惰性删除机制,字符串缩减后的空间不释放,作为预分配空间保留
- SDS遵循C字符串以空字符结尾的惯例,保存空字符的1字节空间不计算在SDS的len属性里面,SDS函数自动完成为空字符分配额外1字节空间和添加空字符操作.**使用惯例的好处是SDS可以重用一部分C字符串函数库里面的函数**

##### (1)SDS与C字符串的区别

###### ①字符串长度与缓冲区溢出

- C字符串本身不记录自身的长度信息，获取C字符串长度必须遍历整个字符串
- 由于C创建字符串要分配足够内存，这很容易造成缓冲区溢出，比如定义好了两个字符串，突然要在内存中靠前的字符串上做拼接操作，这就引发了第二个字符串被覆盖，造成错误，SDS编写了自己的函数解决这个问题

###### ②预先分配机制和惰性空间释放

- 第一次创建len属性等于数据实际大小,free等于0,不做预分配
- 追加字符修改后如果已有free空间不够且数据小于1m,每次预分配一倍容量len=free(==注意:追加操作后字符串对象分配了一倍容量作为预留空间,而且大量追加操作需要内存重新分配从而造成内存碎片==)
- 修改后如果已有free空间不够且数据大于1mb则每次分配1mb空间

如果每次修改字符串长度都要执行一次内存重分配的话，光是执行内存重分配的时间会占去修改字符串所用时间的一大部分，所以SDS通过未使用空间解除了字符串长度和底层数组长度之间的关联

###### ③二进制安全与兼容部分C字符串函数

#### 3.redisObject对象

##### (1)redisObject结构

Redis存储的所有值对象在内部定义为redisObject结构体,结构体内包含type,encoding,lru,refcount和ptr

| type(对象类型)         | string,list,hash,set,zset                                    |
| ---------------------- | ------------------------------------------------------------ |
| encoding(内部编码类型) | 代表当前对象内部采用哪种数据结构实现                         |
| lru                    | 记录对象最后一次被访问的事件,用于辅助LRU算法内存溢出时删除键数据 |
| refcount               | 记录当前对象(整数对象池内的整数)被引用的次数,当refcount=0时内存被回收 |
| ptr                    | 只想底层实现数据结构的指针,例如SDS,如果是整数则直接存储数据,否则表示指向数据的指针 |

##### (2)编码对象

其他对象编码类型就是ptr指向上面所讲的数据结构,这里只重点介绍有序集合对象:

==**zset对象与其他对象的不同就是他不完全是上面介绍到的数据结构编码对象,除了跳跃表结构之外zset对象还有一个hashtable对象来存储obj与score的映射,以方便直接用(O(1))哈希函数找出key所在的哈希表索引以查出分值**==

##### (3)共享对象池

指Redis内部维护[0~9999]的整数对象池,即0到9999的整数值redisObject对象都在Redis的维护下,当有键赋值整数时,键直接指向对象池的对应整数redisObject而不用创建一个redisObject.

**需要注意:当设置maxmemory并启用LRU相关淘汰策略时禁止使用共享对象池,因为LRU不可能被共享**

#### **5.控制键的数量**

(1)通过预估客户端键的规模,把大量键分组映射到多个hash中,比如存在100万个键可以映射到1000个hash中,每个hash保存1000个数据,field用于记录原始key字符串,value用来保存原始值对象.

(2)用hash代替string的原因是存储较多数据时ziplist比sds节约内存,sds结构太消耗内存,不过具体还要看数据量和单个数据大小

**同时需要注意使用hash的缺点:所有的键无法再使用超时和LRU淘汰机制自动删除**

