# 第十二章 服务器

### 一.命令请求执行过程

#### 1.客户端发送命令请求

#### ==2.读取命令请求==

当客户端与服务器之间的连接套接字因为客户端的写入而变得可读时，服务器将调用命令请求处理器来执行一下操作：

* 读取套接字中协议格式的命令请求，并**将其保存到客户端状态的输入缓冲区**里面
* 对输入缓冲区的命令请求进行分析，**提取出命令请求中包含的命令参数，以及命令参数的个数，然后分别将参数和参数个数==保存到客户端状态的argv和argc属性==里面**。
* 调用命令执行器，执行客户端指定的命令。
  

### 二.serverCron函数

serverCron函数默认每隔100ms执行一次,这个函数负责管理服务器资源,并保持服务器自身的良好运转.

#### 1.更新服务器时间缓存

为了减少系统调用函数 来查看当前时间 的执行次数，serverCron函数默认每隔100ms一次的频率更新unixtime（秒级精度的系统当前UNIX时间戳）属性和mstime（毫秒级）属性,所以这两个属性的精确度不高:

* 服务器只会在打印日志,更新服务器的LRU时钟，决定是否执行持久化任务，计算服务器上线时间这类对时间精确度要求不高的功能上使用这两个属性
* 对于为键设置过期时间，添加慢查询日志这种需要高精度时间的功能来说，服务器还是会再次执行系统调用，从而获得最准确的系统当前时间

#### 2.更新LRU时钟

lrulock属性保存了服务器的LRU时钟，serverCron函数以每10秒一次的频率更新lrulock属性的值(所以这是一个模糊估算值)

每个Redis对象都会有一个lru属性**保存了对象最后一次被访问的时间**，当服务器要计算一个数据库键的空转时间，程序会用服务器的lrulock属性记录的时间减去对象的lru属性记录的时间得出空转时间

#### 3.管理客户端资源

serverCron函数每次执行都会调用clientsCron函数对客户端进行以下两个检查:

* 如果客户端与服务器连接超时,那么释放客户端
* 如果客户端在上一次执行命令请求之后,**输入缓冲区的大小超过了一定的长度,那么程序会释放客户端当前的输入缓冲区,并重新创建一个默认大小的输入的输入缓冲区从而防止客户端的输入缓冲区耗费过多的内存**

#### 4.执行被延迟的BGREWRITEAOF

**在服务器执行BGSAVE命令的期间,如果客户端向服务器发来BGWRITEAOF命令,那么服务器会将BGREWRITEAOF命令的执行时间延迟到BGSAVE命令执行完毕之后**

#### ==5.检查持久化操作的运行状态==

服务器状态使用 **rdb_child_pid 属性和 aof_child_pid 属性记录执行 BGSAVE 命令和 BGREWRITEAOF 命令的子进程ID**，这两个属性也可以用于检查BGSAVE命令或者BGREWRITEAOF命令是否正在执行。 
每次serverCron函数执行时，程序都会检查 rdb_child_pid 和 aof_child_pid 两个属性的值，只要其中一个不为-1，程序就会执行一次wait函数，检查子进程是否有信号发来服务器进程：

* 如果有信号到达，那么表示新的RDB文件已经生成完毕（对于BGSAVE命令来说），或者AOF文件已经重写完毕（对于 BGREWRITEAOF 命令来说），服务器需要进行相应命令的后续操作，比如用新的RDB文件 
  替换现有的RDB文件，或者用重写后的AOF文件替换现有的AOF文件。
* 如果没有信号到达，那么表示持久化操作未完成，程序不做操作。



另一方面，**如果==两个属性的值都是-1==，那么表示服务器没有在进行持久化操作**，这时，程序执行以下三个检查:

* 查看是否有 BGREWRITEAOF 被延迟了，如果有，开始执行 BGREWRITEAOF==**(4就是在这里执行)**==
* 检查服务器的自动保存条件是否已经满足，如果条件已经满足，并且服务器没有在执行其他持久化操作，那么服务器开始一次新的BGSAVE操作==**（因为条件1可能执行 BGREWRITEAOF，所以这里再次确认服务器
  没有在执行持久化操作）**==
* 检查服务器的AOF重写条件是否满足，如果满足，并且服务器没有在执行持久化操作，那么服务器将开始一次新的 BGREWRITEAOF 操作。(原因同上)

